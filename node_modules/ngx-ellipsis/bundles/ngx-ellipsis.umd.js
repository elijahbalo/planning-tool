(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('element-resize-detector')) :
    typeof define === 'function' && define.amd ? define('ngx-ellipsis', ['exports', '@angular/core', 'element-resize-detector'], factory) :
    (factory((global['ngx-ellipsis'] = {}),global.ng.core,null));
}(this, (function (exports,core,elementResizeDetectorMaker) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Directive to truncate the contained text, if it exceeds the element's boundaries
     * and append characters (configurable, default '...') if so.
     */
    var EllipsisDirective = (function () {
        function EllipsisDirective(elementRef, renderer, ngZone) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.ngZone = ngZone;
            /**
             * Whether the ellipsis should be applied on window resize
             */
            this.applyOnWindowResize = false;
            /**
             * The ellipsis-content html attribute
             * If passed this is used as content, else contents
             * are fetched from innerHTML
             */
            this.ellipsisContent = null;
            /**
             * The ellipsis-click-more html attribute
             *  If anything is passed, the ellipsisCharacters will be
             *  wrapped in <a></a> tags and an event handler for the
             *  passed function will be added to the link
             */
            this.moreClickEmitter = new core.EventEmitter();
        }
        /**
         * Utility method to quickly find the largest number for
         * which `callback(number)` still returns true.
         * @param {?} max      Highest possible number
         * @param {?} callback Should return true as long as the passed number is valid
         * @return {?} Largest possible number
         */
        EllipsisDirective.numericBinarySearch = /**
         * Utility method to quickly find the largest number for
         * which `callback(number)` still returns true.
         * @param {?} max      Highest possible number
         * @param {?} callback Should return true as long as the passed number is valid
         * @return {?} Largest possible number
         */
            function (max, callback) {
                /** @type {?} */
                var low = 0;
                /** @type {?} */
                var high = max;
                /** @type {?} */
                var best = -1;
                /** @type {?} */
                var mid;
                while (low <= high) {
                    // tslint:disable-next-line:no-bitwise
                    mid = ~~((low + high) / 2);
                    /** @type {?} */
                    var result = callback(mid);
                    if (!result) {
                        high = mid - 1;
                    }
                    else {
                        best = mid;
                        low = mid + 1;
                    }
                }
                return best;
            };
        /**
         * Angular's init view life cycle hook.
         * Initializes the element for displaying the ellipsis.
         */
        /**
         * Angular's init view life cycle hook.
         * Initializes the element for displaying the ellipsis.
         * @return {?}
         */
        EllipsisDirective.prototype.ngAfterViewInit = /**
         * Angular's init view life cycle hook.
         * Initializes the element for displaying the ellipsis.
         * @return {?}
         */
            function () {
                // let the ellipsis characters default to '...':
                if (this.ellipsisCharacters === '') {
                    this.ellipsisCharacters = '...';
                }
                if (this.moreClickEmitter.observers.length > 0) {
                    this.ellipsisCharacters = "<a href=\"#\" class=\"ngx-ellipsis-more\">" + this.ellipsisCharacters + "</a>";
                }
                // perform regex replace on word boundaries:
                if (!this.ellipsisWordBoundaries) {
                    this.ellipsisWordBoundaries = '';
                }
                this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
                // store the original contents of the element:
                this.elem = this.elementRef.nativeElement;
                if (this.ellipsisContent) {
                    this.originalText = this.ellipsisContent;
                }
                else if (!this.originalText) {
                    this.originalText = this.elem.innerText;
                }
                // add a wrapper div (required for resize events to work properly):
                this.renderer.setProperty(this.elem, 'innerHTML', '');
                this.innerElem = this.renderer.createElement('div');
                this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
                /** @type {?} */
                var text = this.renderer.createText(this.originalText);
                this.renderer.appendChild(this.innerElem, text);
                this.renderer.appendChild(this.elem, this.innerElem);
                // start listening for resize events:
                this.addResizeListener(true);
            };
        /**
         * Angular's change life cycle hook.
         * Change original text (if the ellipsis-content has been passed)
         * and re-render
         */
        /**
         * Angular's change life cycle hook.
         * Change original text (if the ellipsis-content has been passed)
         * and re-render
         * @return {?}
         */
        EllipsisDirective.prototype.ngOnChanges = /**
         * Angular's change life cycle hook.
         * Change original text (if the ellipsis-content has been passed)
         * and re-render
         * @return {?}
         */
            function () {
                if (!this.elem || typeof this.ellipsisContent === 'undefined' || this.originalText === this.ellipsisContent) {
                    return;
                }
                this.originalText = this.ellipsisContent;
                this.applyEllipsis();
            };
        /**
         * Angular's destroy life cycle hook.
         * Remove event listeners
         */
        /**
         * Angular's destroy life cycle hook.
         * Remove event listeners
         * @return {?}
         */
        EllipsisDirective.prototype.ngOnDestroy = /**
         * Angular's destroy life cycle hook.
         * Remove event listeners
         * @return {?}
         */
            function () {
                this.removeAllListeners();
            };
        /**
         * remove all resize listeners
         * @return {?}
         */
        EllipsisDirective.prototype.removeAllListeners = /**
         * remove all resize listeners
         * @return {?}
         */
            function () {
                if (this.destroyMoreClickListener) {
                    this.destroyMoreClickListener();
                }
                this.removeResizeListener();
            };
        /**
         * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
         * The type of the listener (window/element) depends on the resizeDetectionStrategy.
         * @param {?=} triggerNow
         * @return {?}
         */
        EllipsisDirective.prototype.addResizeListener = /**
         * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
         * The type of the listener (window/element) depends on the resizeDetectionStrategy.
         * @param {?=} triggerNow
         * @return {?}
         */
            function (triggerNow) {
                if (triggerNow === void 0) {
                    triggerNow = false;
                }
                if (typeof (this.resizeDetectionStrategy) === 'undefined') {
                    this.resizeDetectionStrategy = '';
                }
                switch (this.resizeDetectionStrategy) {
                    case 'window':
                        this.applyOnWindowResize = true;
                        if (triggerNow) {
                            this.applyEllipsis();
                        }
                        break;
                    case 'element-resize-detector-object':
                        this.addElementResizeListener(false);
                        break;
                    default:
                        if (typeof (console) !== 'undefined') {
                            console.warn("No such ellipsis-resize-detection strategy: '" + this.resizeDetectionStrategy + "'. Using 'element-resize-detector' instead");
                        }
                    // tslint:disable-next-line:no-switch-case-fall-through
                    case 'element-resize-detector':
                    case '':
                        this.addElementResizeListener();
                        break;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        EllipsisDirective.prototype.onResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.ngZone.run(function () {
                    if (_this.applyOnWindowResize) {
                        _this.applyEllipsis();
                    }
                });
            };
        /**
         * Set up an event listener to call applyEllipsis() whenever the element
         * has been resized.
         * @param {?=} scrollStrategy
         * @return {?}
         */
        EllipsisDirective.prototype.addElementResizeListener = /**
         * Set up an event listener to call applyEllipsis() whenever the element
         * has been resized.
         * @param {?=} scrollStrategy
         * @return {?}
         */
            function (scrollStrategy) {
                var _this = this;
                if (scrollStrategy === void 0) {
                    scrollStrategy = true;
                }
                if (!EllipsisDirective.elementResizeDetector) {
                    /** @type {?} */
                    var maker = elementResizeDetectorMaker;
                    EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
                }
                /** @type {?} */
                var calledAsynchronously = false;
                EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, function () {
                    if (!calledAsynchronously) {
                        // elementResizeDetector fires the event directly after re-attaching the listener
                        // -> discard that first event:
                        return;
                    }
                    _this.applyEllipsis();
                });
                calledAsynchronously = true;
            };
        /**
         * Stop listening for any resize event.
         * @return {?}
         */
        EllipsisDirective.prototype.removeResizeListener = /**
         * Stop listening for any resize event.
         * @return {?}
         */
            function () {
                if (this.resizeDetectionStrategy !== 'window') {
                    if (EllipsisDirective.elementResizeDetector && this.elem) {
                        EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
                    }
                }
                else {
                    this.applyOnWindowResize = false;
                }
            };
        /**
         * Get the original text's truncated version. If the text really needed to
         * be truncated, this.ellipsisCharacters will be appended.
         * @param {?} max the maximum length the text may have
         * @return {?} string       the truncated string
         */
        EllipsisDirective.prototype.getTruncatedText = /**
         * Get the original text's truncated version. If the text really needed to
         * be truncated, this.ellipsisCharacters will be appended.
         * @param {?} max the maximum length the text may have
         * @return {?} string       the truncated string
         */
            function (max) {
                if (!this.originalText || this.originalText.length <= max) {
                    return this.originalText;
                }
                /** @type {?} */
                var truncatedText = this.originalText.substr(0, max);
                if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
                    return truncatedText + this.ellipsisCharacters;
                }
                /** @type {?} */
                var i = max - 1;
                while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
                    i--;
                }
                return truncatedText.substr(0, i) + this.ellipsisCharacters;
            };
        /**
         * Set the truncated text to be displayed in the inner div
         * @param {?} max the maximum length the text may have
         * @param {?=} addMoreListener
         * @return {?}
         */
        EllipsisDirective.prototype.truncateText = /**
         * Set the truncated text to be displayed in the inner div
         * @param {?} max the maximum length the text may have
         * @param {?=} addMoreListener
         * @return {?}
         */
            function (max, addMoreListener) {
                var _this = this;
                if (addMoreListener === void 0) {
                    addMoreListener = false;
                }
                /** @type {?} */
                var text = this.getTruncatedText(max);
                this.renderer.setProperty(this.innerElem, 'innerHTML', text);
                if (!addMoreListener) {
                    return;
                }
                // Remove any existing more click listener:
                if (this.destroyMoreClickListener) {
                    this.destroyMoreClickListener();
                }
                // If the text has been truncated, add a more click listener:
                if (text !== this.originalText) {
                    this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', function (e) {
                        if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                            return;
                        }
                        e.preventDefault();
                        _this.moreClickEmitter.emit(e);
                    });
                }
            };
        /**
         * Display ellipsis in the inner div if the text would exceed the boundaries
         * @return {?}
         */
        EllipsisDirective.prototype.applyEllipsis = /**
         * Display ellipsis in the inner div if the text would exceed the boundaries
         * @return {?}
         */
            function () {
                var _this = this;
                // Remove the resize listener as changing the contained text would trigger events:
                this.removeResizeListener();
                /** @type {?} */
                var maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, function (curLength) {
                    _this.truncateText(curLength);
                    return !_this.isOverflowing;
                });
                // Apply the best length:
                this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
                // Re-attach the resize listener:
                this.addResizeListener();
            };
        Object.defineProperty(EllipsisDirective.prototype, "isOverflowing", {
            get: /**
             * Whether the text is exceeding the element's boundaries or not
             * @return {?}
             */ function () {
                /** @type {?} */
                var currentOverflow = this.elem.style.overflow;
                if (!currentOverflow || currentOverflow === 'visible') {
                    this.elem.style.overflow = 'hidden';
                }
                /** @type {?} */
                var isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
                // Reset overflow to the original configuration:
                this.elem.style.overflow = currentOverflow;
                return isOverflowing;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Instance of https://github.com/wnr/element-resize-detector
         */
        EllipsisDirective.elementResizeDetector = null;
        EllipsisDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ellipsis]'
                    },] },
        ];
        /** @nocollapse */
        EllipsisDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.NgZone }
            ];
        };
        EllipsisDirective.propDecorators = {
            ellipsisCharacters: [{ type: core.Input, args: ['ellipsis',] }],
            ellipsisContent: [{ type: core.Input, args: ['ellipsis-content',] }],
            ellipsisWordBoundaries: [{ type: core.Input, args: ['ellipsis-word-boundaries',] }],
            resizeDetectionStrategy: [{ type: core.Input, args: ['ellipsis-resize-detection',] }],
            moreClickEmitter: [{ type: core.Output, args: ['ellipsis-click-more',] }],
            onResize: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }]
        };
        return EllipsisDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var EllipsisModule = (function () {
        function EllipsisModule() {
        }
        EllipsisModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [EllipsisDirective],
                        exports: [EllipsisDirective]
                    },] },
        ];
        return EllipsisModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.EllipsisDirective = EllipsisDirective;
    exports.EllipsisModule = EllipsisModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWVsbGlwc2lzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWVsbGlwc2lzL2xpYi9kaXJlY3RpdmVzL2VsbGlwc2lzLmRpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWVsbGlwc2lzL2xpYi9lbGxpcHNpcy5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBSZW5kZXJlcjIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgTmdab25lLFxuICBIb3N0TGlzdGVuZXIsXG4gIE9uQ2hhbmdlcyxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIgZnJvbSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIERpcmVjdGl2ZSB0byB0cnVuY2F0ZSB0aGUgY29udGFpbmVkIHRleHQsIGlmIGl0IGV4Y2VlZHMgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzXG4gKiBhbmQgYXBwZW5kIGNoYXJhY3RlcnMgKGNvbmZpZ3VyYWJsZSwgZGVmYXVsdCAnLi4uJykgaWYgc28uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlbGxpcHNpc10nXG59KVxuZXhwb3J0IGNsYXNzIEVsbGlwc2lzRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZWxlbWVudFJlc2l6ZURldGVjdG9yOiBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlci5FcmQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgdGV4dCAobm90IHRydW5jYXRlZCB5ZXQpXG4gICAqL1xuICBwcml2YXRlIG9yaWdpbmFsVGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVmZXJlbmNlZCBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIGVsZW06IGFueTtcblxuICAvKipcbiAgICogSW5uZXIgZGl2IGVsZW1lbnQgKHdpbGwgYmUgYXV0by1jcmVhdGVkKVxuICAgKi9cbiAgcHJpdmF0ZSBpbm5lckVsZW06IGFueTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZWxsaXBzaXMgc2hvdWxkIGJlIGFwcGxpZWQgb24gd2luZG93IHJlc2l6ZVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseU9uV2luZG93UmVzaXplID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGNsaWNrIGxpc3RlbmVyXG4gICAqIG9uIHRoZSBsaW5rIGB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc2AgYXJlIHdyYXBwZWQgaW4uXG4gICAqL1xuICBwcml2YXRlIGRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzIGh0bWwgYXR0cmlidXRlXG4gICAqIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhpcyB3aWxsIGJlIHVzZWQgYXMgYSBzdHJpbmcgdG8gYXBwZW5kIHRvXG4gICAqIHRoZSB0cnVuY2F0ZWQgY29udGVudHMuXG4gICAqIEVsc2UgJy4uLicgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMnKSBlbGxpcHNpc0NoYXJhY3RlcnM6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNvbnRlbnQgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgcGFzc2VkIHRoaXMgaXMgdXNlZCBhcyBjb250ZW50LCBlbHNlIGNvbnRlbnRzXG4gICAqIGFyZSBmZXRjaGVkIGZyb20gaW5uZXJIVE1MXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLWNvbnRlbnQnKSBlbGxpcHNpc0NvbnRlbnQ6IHN0cmluZyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCBlYWNoIGNoYXJhY3RlciB3aWxsIGJlIGludGVycHJldGVkXG4gICAqIGFzIGEgd29yZCBib3VuZGFyeSBhdCB3aGljaCB0aGUgdGV4dCBtYXkgYmUgdHJ1bmNhdGVkLlxuICAgKiBFbHNlIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQgYXQgYW55IGNoYXJhY3Rlci5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtd29yZC1ib3VuZGFyaWVzJykgZWxsaXBzaXNXb3JkQm91bmRhcmllczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtcmVzaXplLWRldGVjdGlvbiBodG1sIGF0dHJpYnV0ZVxuICAgKiBBbGdvcml0aG0gdG8gdXNlIHRvIGRldGVjdCBlbGVtZW50L3dpbmRvdyByZXNpemUgLSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzogKGRlZmF1bHQpIFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdzY3JvbGwnIHN0cmF0ZWd5XG4gICAqICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnOiBVc2UgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvciB3aXRoIGl0cyAnb2JqZWN0JyBzdHJhdGVneSAoZGVwcmVjYXRlZClcbiAgICogJ3dpbmRvdyc6IE9ubHkgY2hlY2sgaWYgdGhlIHdob2xlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkL2NoYW5nZWQgb3JpZW50YXRpb24gYnkgdXNpbmcgYW5ndWxhcidzIGJ1aWx0LWluIEhvc3RMaXN0ZW5lclxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uJykgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3k6ICcnIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJyB8ICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnIHwgJ3dpbmRvdyc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1jbGljay1tb3JlIGh0bWwgYXR0cmlidXRlXG4gICAqICBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIHRoZSBlbGxpcHNpc0NoYXJhY3RlcnMgd2lsbCBiZVxuICAgKiAgd3JhcHBlZCBpbiA8YT48L2E+IHRhZ3MgYW5kIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZVxuICAgKiAgcGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpbmtcbiAgICovXG4gIEBPdXRwdXQoJ2VsbGlwc2lzLWNsaWNrLW1vcmUnKSBtb3JlQ2xpY2tFbWl0dGVyOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCB0byBxdWlja2x5IGZpbmQgdGhlIGxhcmdlc3QgbnVtYmVyIGZvclxuICAgKiB3aGljaCBgY2FsbGJhY2sobnVtYmVyKWAgc3RpbGwgcmV0dXJucyB0cnVlLlxuICAgKiBAcGFyYW0gIG1heCAgICAgIEhpZ2hlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqIEBwYXJhbSAgY2FsbGJhY2sgU2hvdWxkIHJldHVybiB0cnVlIGFzIGxvbmcgYXMgdGhlIHBhc3NlZCBudW1iZXIgaXMgdmFsaWRcbiAgICogQHJldHVybiAgICAgICAgICBMYXJnZXN0IHBvc3NpYmxlIG51bWJlclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgbnVtZXJpY0JpbmFyeVNlYXJjaChtYXg6IG51bWJlciwgY2FsbGJhY2s6IChuOiBudW1iZXIpID0+IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gbWF4O1xuICAgIGxldCBiZXN0ID0gLTE7XG4gICAgbGV0IG1pZDogbnVtYmVyO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgICAgbWlkID0gfn4oKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayhtaWQpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXN0ID0gbWlkO1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RpdmUncyBjb25zdHJ1Y3RvclxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIG5nWm9uZTogTmdab25lKSB7IH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGluaXQgdmlldyBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIEluaXRpYWxpemVzIHRoZSBlbGVtZW50IGZvciBkaXNwbGF5aW5nIHRoZSBlbGxpcHNpcy5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBsZXQgdGhlIGVsbGlwc2lzIGNoYXJhY3RlcnMgZGVmYXVsdCB0byAnLi4uJzpcbiAgICBpZiAodGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPT09ICcnKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9ICcuLi4nO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vcmVDbGlja0VtaXR0ZXIub2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gYDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJuZ3gtZWxsaXBzaXMtbW9yZVwiPiR7dGhpcy5lbGxpcHNpc0NoYXJhY3RlcnN9PC9hPmA7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSByZWdleCByZXBsYWNlIG9uIHdvcmQgYm91bmRhcmllczpcbiAgICBpZiAoIXRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykge1xuICAgICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJyc7XG4gICAgfVxuICAgIHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9ICdbJyArIHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcy5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKS5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSArICddJztcblxuICAgIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBjb250ZW50cyBvZiB0aGUgZWxlbWVudDpcbiAgICB0aGlzLmVsZW0gPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBpZiAodGhpcy5lbGxpcHNpc0NvbnRlbnQpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gdGhpcy5lbGxpcHNpc0NvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5vcmlnaW5hbFRleHQpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gdGhpcy5lbGVtLmlubmVyVGV4dDtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSB3cmFwcGVyIGRpdiAocmVxdWlyZWQgZm9yIHJlc2l6ZSBldmVudHMgdG8gd29yayBwcm9wZXJseSk6XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW0sICdpbm5lckhUTUwnLCAnJyk7XG4gICAgdGhpcy5pbm5lckVsZW0gPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5pbm5lckVsZW0sICduZ3gtZWxsaXBzaXMtaW5uZXInKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVUZXh0KHRoaXMub3JpZ2luYWxUZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJFbGVtLCB0ZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbSwgdGhpcy5pbm5lckVsZW0pO1xuXG4gICAgLy8gc3RhcnQgbGlzdGVuaW5nIGZvciByZXNpemUgZXZlbnRzOlxuICAgIHRoaXMuYWRkUmVzaXplTGlzdGVuZXIodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGNoYW5nZSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIENoYW5nZSBvcmlnaW5hbCB0ZXh0IChpZiB0aGUgZWxsaXBzaXMtY29udGVudCBoYXMgYmVlbiBwYXNzZWQpXG4gICAqIGFuZCByZS1yZW5kZXJcbiAgICovXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIGlmICghdGhpcy5lbGVtIHx8IHR5cGVvZiB0aGlzLmVsbGlwc2lzQ29udGVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5vcmlnaW5hbFRleHQgPT09IHRoaXMuZWxsaXBzaXNDb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsbGlwc2lzQ29udGVudDtcbiAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgZGVzdHJveSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGFsbCByZXNpemUgbGlzdGVuZXJzXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVSZXNpemVMaXN0ZW5lcigpO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGNhbGwgYXBwbHlFbGxpcHNpcygpIHdoZW5ldmVyIGEgcmVzaXplIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBsaXN0ZW5lciAod2luZG93L2VsZW1lbnQpIGRlcGVuZHMgb24gdGhlIHJlc2l6ZURldGVjdGlvblN0cmF0ZWd5LlxuICAgKiBAcGFyYW0gdHJpZ2dlck5vdz1mYWxzZSBpZiB0cnVlLCB0aGUgZWxsaXBzaXMgaXMgYXBwbGllZCBpbW1lZGlhdGVseVxuICAgKi9cbiAgcHJpdmF0ZSBhZGRSZXNpemVMaXN0ZW5lcih0cmlnZ2VyTm93ID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kgPSAnJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ3dpbmRvdyc6XG4gICAgICAgIHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSA9IHRydWU7XG4gICAgICAgIGlmICh0cmlnZ2VyTm93KSB7XG4gICAgICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnOlxuICAgICAgICB0aGlzLmFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcihmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHR5cGVvZiAoY29uc29sZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYE5vIHN1Y2ggZWxsaXBzaXMtcmVzaXplLWRldGVjdGlvbiBzdHJhdGVneTogJyR7dGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneX0nLiBVc2luZyAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InIGluc3RlYWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN3aXRjaC1jYXNlLWZhbGwtdGhyb3VnaFxuICAgICAgY2FzZSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignd2luZG93OnJlc2l6ZScsIFsnJGV2ZW50J10pIG9uUmVzaXplKGV2ZW50OiBFdmVudCkge1xuICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5hcHBseU9uV2luZG93UmVzaXplKSB7XG4gICAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBjYWxsIGFwcGx5RWxsaXBzaXMoKSB3aGVuZXZlciB0aGUgZWxlbWVudFxuICAgKiBoYXMgYmVlbiByZXNpemVkLlxuICAgKiBAcGFyYW0gc2Nyb2xsU3RyYXRlZ3k9dHJ1ZSBVc2UgdGhlIGRlZmF1bHQgZWxlbWVudFJlc2l6ZURldGVjdG9yJ3MgLSBzdHJhdGVneSAtIHMuIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3JcbiAgICovXG4gIHByaXZhdGUgYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKHNjcm9sbFN0cmF0ZWd5ID0gdHJ1ZSkge1xuICAgIGlmICghRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yKSB7XG4gICAgICBjb25zdCBtYWtlcjogYW55ID0gZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXI7XG4gICAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IgPSBtYWtlcih7IHN0cmF0ZWd5OiBzY3JvbGxTdHJhdGVneSA/ICdzY3JvbGwnIDogJ29iamVjdCcgfSk7XG4gICAgfVxuXG5cbiAgICBsZXQgY2FsbGVkQXN5bmNocm9ub3VzbHkgPSBmYWxzZTtcbiAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IubGlzdGVuVG8odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICgpID0+IHtcbiAgICAgIGlmICghY2FsbGVkQXN5bmNocm9ub3VzbHkpIHtcbiAgICAgICAgLy8gZWxlbWVudFJlc2l6ZURldGVjdG9yIGZpcmVzIHRoZSBldmVudCBkaXJlY3RseSBhZnRlciByZS1hdHRhY2hpbmcgdGhlIGxpc3RlbmVyXG4gICAgICAgIC8vIC0+IGRpc2NhcmQgdGhhdCBmaXJzdCBldmVudDpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgfSk7XG4gICAgY2FsbGVkQXN5bmNocm9ub3VzbHkgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIGZvciBhbnkgcmVzaXplIGV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVSZXNpemVMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSAhPT0gJ3dpbmRvdycpIHtcbiAgICAgIGlmIChFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IgJiYgdGhpcy5lbGVtKSB7XG4gICAgICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvci5yZW1vdmVBbGxMaXN0ZW5lcnModGhpcy5lbGVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBseU9uV2luZG93UmVzaXplID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luYWwgdGV4dCdzIHRydW5jYXRlZCB2ZXJzaW9uLiBJZiB0aGUgdGV4dCByZWFsbHkgbmVlZGVkIHRvXG4gICAqIGJlIHRydW5jYXRlZCwgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggdGhlIHRleHQgbWF5IGhhdmVcbiAgICogQHJldHVybiBzdHJpbmcgICAgICAgdGhlIHRydW5jYXRlZCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgZ2V0VHJ1bmNhdGVkVGV4dChtYXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCB8fCB0aGlzLm9yaWdpbmFsVGV4dC5sZW5ndGggPD0gbWF4KSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFRleHQ7XG4gICAgfVxuXG4gICAgY29uc3QgdHJ1bmNhdGVkVGV4dCA9IHRoaXMub3JpZ2luYWxUZXh0LnN1YnN0cigwLCBtYXgpO1xuICAgIGlmICh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPT09ICdbXScgfHwgdGhpcy5vcmlnaW5hbFRleHQuY2hhckF0KG1heCkubWF0Y2godGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSkge1xuICAgICAgcmV0dXJuIHRydW5jYXRlZFRleHQgKyB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycztcbiAgICB9XG5cbiAgICBsZXQgaSA9IG1heCAtIDE7XG4gICAgd2hpbGUgKGkgPiAwICYmICF0cnVuY2F0ZWRUZXh0LmNoYXJBdChpKS5tYXRjaCh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpKSB7XG4gICAgICBpLS07XG4gICAgfVxuICAgIHJldHVybiB0cnVuY2F0ZWRUZXh0LnN1YnN0cigwLCBpKSArIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJ1bmNhdGVkIHRleHQgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBpbm5lciBkaXZcbiAgICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggdGhlIHRleHQgbWF5IGhhdmVcbiAgICogQHBhcmFtIGFkZE1vcmVMaXN0ZW5lcj1mYWxzZSBsaXN0ZW4gZm9yIGNsaWNrIG9uIHRoZSBlbGxpcHNpc0NoYXJhY3RlcnMgaWYgdGhlIHRleHQgaGFzIGJlZW4gdHJ1bmNhdGVkXG4gICAqL1xuICBwcml2YXRlIHRydW5jYXRlVGV4dChtYXg6IG51bWJlciwgYWRkTW9yZUxpc3RlbmVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRUcnVuY2F0ZWRUZXh0KG1heCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmlubmVyRWxlbSwgJ2lubmVySFRNTCcsIHRleHQpO1xuXG4gICAgaWYgKCFhZGRNb3JlTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIG1vcmUgY2xpY2sgbGlzdGVuZXI6XG4gICAgaWYgKHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZCwgYWRkIGEgbW9yZSBjbGljayBsaXN0ZW5lcjpcbiAgICBpZiAodGV4dCAhPT0gdGhpcy5vcmlnaW5hbFRleHQpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5pbm5lckVsZW0sICdjbGljaycsIChlOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKCFlLnRhcmdldCB8fCBlLnRhcmdldC5jbGFzc05hbWUgIT09ICduZ3gtZWxsaXBzaXMtbW9yZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm1vcmVDbGlja0VtaXR0ZXIuZW1pdChlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IGVsbGlwc2lzIGluIHRoZSBpbm5lciBkaXYgaWYgdGhlIHRleHQgd291bGQgZXhjZWVkIHRoZSBib3VuZGFyaWVzXG4gICAqL1xuICBwcml2YXRlIGFwcGx5RWxsaXBzaXMoKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSByZXNpemUgbGlzdGVuZXIgYXMgY2hhbmdpbmcgdGhlIGNvbnRhaW5lZCB0ZXh0IHdvdWxkIHRyaWdnZXIgZXZlbnRzOlxuICAgIHRoaXMucmVtb3ZlUmVzaXplTGlzdGVuZXIoKTtcblxuICAgIC8vIEZpbmQgdGhlIGJlc3QgbGVuZ3RoIGJ5IHRyaWFsIGFuZCBlcnJvcjpcbiAgICBjb25zdCBtYXhMZW5ndGggPSBFbGxpcHNpc0RpcmVjdGl2ZS5udW1lcmljQmluYXJ5U2VhcmNoKHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCwgY3VyTGVuZ3RoID0+IHtcbiAgICAgIHRoaXMudHJ1bmNhdGVUZXh0KGN1ckxlbmd0aCk7XG4gICAgICByZXR1cm4gIXRoaXMuaXNPdmVyZmxvd2luZztcbiAgICB9KTtcblxuICAgIC8vIEFwcGx5IHRoZSBiZXN0IGxlbmd0aDpcbiAgICB0aGlzLnRydW5jYXRlVGV4dChtYXhMZW5ndGgsICh0aGlzLm1vcmVDbGlja0VtaXR0ZXIub2JzZXJ2ZXJzLmxlbmd0aCA+IDApKTtcblxuICAgIC8vIFJlLWF0dGFjaCB0aGUgcmVzaXplIGxpc3RlbmVyOlxuICAgIHRoaXMuYWRkUmVzaXplTGlzdGVuZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHRleHQgaXMgZXhjZWVkaW5nIHRoZSBlbGVtZW50J3MgYm91bmRhcmllcyBvciBub3RcbiAgICovXG4gIHByaXZhdGUgZ2V0IGlzT3ZlcmZsb3dpbmcoKTogYm9vbGVhbiB7XG4gICAgLy8gRW5mb3JjZSBoaWRkZW4gb3ZlcmZsb3cgKHJlcXVpcmVkIHRvIGNvbXBhcmUgY2xpZW50IHdpZHRoL2hlaWdodCB3aXRoIHNjcm9sbCB3aWR0aC9oZWlnaHQpXG4gICAgY29uc3QgY3VycmVudE92ZXJmbG93ID0gdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93O1xuICAgIGlmICghY3VycmVudE92ZXJmbG93IHx8IGN1cnJlbnRPdmVyZmxvdyA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjb25zdCBpc092ZXJmbG93aW5nID0gdGhpcy5lbGVtLmNsaWVudFdpZHRoIDwgdGhpcy5lbGVtLnNjcm9sbFdpZHRoIC0gMSB8fCB0aGlzLmVsZW0uY2xpZW50SGVpZ2h0IDwgdGhpcy5lbGVtLnNjcm9sbEhlaWdodCAtIDE7XG5cbiAgICAvLyBSZXNldCBvdmVyZmxvdyB0byB0aGUgb3JpZ2luYWwgY29uZmlndXJhdGlvbjpcbiAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSBjdXJyZW50T3ZlcmZsb3c7XG5cbiAgICByZXR1cm4gaXNPdmVyZmxvd2luZztcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVsbGlwc2lzRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL2VsbGlwc2lzLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbRWxsaXBzaXNEaXJlY3RpdmVdLFxuICBleHBvcnRzOiBbRWxsaXBzaXNEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIEVsbGlwc2lzTW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsIkRpcmVjdGl2ZSIsIkVsZW1lbnRSZWYiLCJSZW5kZXJlcjIiLCJOZ1pvbmUiLCJJbnB1dCIsIk91dHB1dCIsIkhvc3RMaXN0ZW5lciIsIk5nTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7O21DQThINkIsVUFBc0IsRUFBVSxRQUFtQixFQUFVLE1BQWM7WUFBM0UsZUFBVSxHQUFWLFVBQVUsQ0FBWTtZQUFVLGFBQVEsR0FBUixRQUFRLENBQVc7WUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFROzs7O3VDQWhGeEUsS0FBSzs7Ozs7O21DQXFCa0IsSUFBSTs7Ozs7OztvQ0F5QlksSUFBSUEsaUJBQVksRUFBRTs7Ozs7Ozs7O1FBVXhFLHFDQUFtQjs7Ozs7OztzQkFBQyxHQUFXLEVBQUUsUUFBZ0M7O2dCQUM5RSxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7O2dCQUNaLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQzs7Z0JBQ2YsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7O2dCQUNkLElBQUksR0FBRyxDQUFTO2dCQUVoQixPQUFPLEdBQUcsSUFBSSxJQUFJLEVBQUU7O29CQUVsQixHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQzs7b0JBQzNCLElBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDN0IsSUFBSSxDQUFDLE1BQU0sRUFBRTt3QkFDWCxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztxQkFDaEI7eUJBQU07d0JBQ0wsSUFBSSxHQUFHLEdBQUcsQ0FBQzt3QkFDWCxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztxQkFDZjtpQkFDRjtnQkFFRCxPQUFPLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7UUFZZCwyQ0FBZTs7Ozs7WUFBZjs7Z0JBRUUsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEtBQUssRUFBRSxFQUFFO29CQUNsQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFD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