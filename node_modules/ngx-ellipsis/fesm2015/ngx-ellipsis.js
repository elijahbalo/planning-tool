import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, HostListener, NgModule } from '@angular/core';
import * as elementResizeDetectorMaker from 'element-resize-detector';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
class EllipsisDirective {
    /**
     * The directive's constructor
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(elementRef, renderer, ngZone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Whether the ellipsis should be applied on window resize
         */
        this.applyOnWindowResize = false;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from innerHTML
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         *  If anything is passed, the ellipsisCharacters will be
         *  wrapped in <a></a> tags and an event handler for the
         *  passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    static numericBinarySearch(max, callback) {
        /** @type {?} */
        let low = 0;
        /** @type {?} */
        let high = max;
        /** @type {?} */
        let best = -1;
        /** @type {?} */
        let mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            /** @type {?} */
            const result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    }
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    ngAfterViewInit() {
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        if (this.moreClickEmitter.observers.length > 0) {
            this.ellipsisCharacters = `<a href="#" class="ngx-ellipsis-more">${this.ellipsisCharacters}</a>`;
        }
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (this.ellipsisContent) {
            this.originalText = this.ellipsisContent;
        }
        else if (!this.originalText) {
            this.originalText = this.elem.innerText;
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        /** @type {?} */
        const text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    }
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    ngOnChanges() {
        if (!this.elem || typeof this.ellipsisContent === 'undefined' || this.originalText === this.ellipsisContent) {
            return;
        }
        this.originalText = this.ellipsisContent;
        this.applyEllipsis();
    }
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    ngOnDestroy() {
        this.removeAllListeners();
    }
    /**
     * remove all resize listeners
     * @return {?}
     */
    removeAllListeners() {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    addResizeListener(triggerNow = false) {
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'window':
                this.applyOnWindowResize = true;
                if (triggerNow) {
                    this.applyEllipsis();
                }
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn(`No such ellipsis-resize-detection strategy: '${this.resizeDetectionStrategy}'. Using 'element-resize-detector' instead`);
                }
            // tslint:disable-next-line:no-switch-case-fall-through
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.ngZone.run(() => {
            if (this.applyOnWindowResize) {
                this.applyEllipsis();
            }
        });
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    addElementResizeListener(scrollStrategy = true) {
        if (!EllipsisDirective.elementResizeDetector) {
            /** @type {?} */
            const maker = elementResizeDetectorMaker;
            EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        /** @type {?} */
        let calledAsynchronously = false;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, () => {
            if (!calledAsynchronously) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                return;
            }
            this.applyEllipsis();
        });
        calledAsynchronously = true;
    }
    /**
     * Stop listening for any resize event.
     * @return {?}
     */
    removeResizeListener() {
        if (this.resizeDetectionStrategy !== 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.applyOnWindowResize = false;
        }
    }
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    getTruncatedText(max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        /** @type {?} */
        const truncatedText = this.originalText.substr(0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText + this.ellipsisCharacters;
        }
        /** @type {?} */
        let i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return truncatedText.substr(0, i) + this.ellipsisCharacters;
    }
    /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    truncateText(max, addMoreListener = false) {
        /** @type {?} */
        const text = this.getTruncatedText(max);
        this.renderer.setProperty(this.innerElem, 'innerHTML', text);
        if (!addMoreListener) {
            return;
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        // If the text has been truncated, add a more click listener:
        if (text !== this.originalText) {
            this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', (e) => {
                if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                this.moreClickEmitter.emit(e);
            });
        }
    }
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    applyEllipsis() {
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        /** @type {?} */
        const maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, curLength => {
            this.truncateText(curLength);
            return !this.isOverflowing;
        });
        // Apply the best length:
        this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
        // Re-attach the resize listener:
        this.addResizeListener();
    }
    /**
     * Whether the text is exceeding the element's boundaries or not
     * @return {?}
     */
    get isOverflowing() {
        /** @type {?} */
        const currentOverflow = this.elem.style.overflow;
        if (!currentOverflow || currentOverflow === 'visible') {
            this.elem.style.overflow = 'hidden';
        }
        /** @type {?} */
        const isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
        // Reset overflow to the original configuration:
        this.elem.style.overflow = currentOverflow;
        return isOverflowing;
    }
}
/**
 * Instance of https://github.com/wnr/element-resize-detector
 */
EllipsisDirective.elementResizeDetector = null;
EllipsisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ellipsis]'
            },] },
];
/** @nocollapse */
EllipsisDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
EllipsisDirective.propDecorators = {
    ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
    ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
    ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
    resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
    moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class EllipsisModule {
}
EllipsisModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [EllipsisDirective],
                exports: [EllipsisDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { EllipsisDirective, EllipsisModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWVsbGlwc2lzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtZWxsaXBzaXMvbGliL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtZWxsaXBzaXMvbGliL2VsbGlwc2lzLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIFJlbmRlcmVyMixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBOZ1pvbmUsXG4gIEhvc3RMaXN0ZW5lcixcbiAgT25DaGFuZ2VzLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlciBmcm9tICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIHRydW5jYXRlIHRoZSBjb250YWluZWQgdGV4dCwgaWYgaXQgZXhjZWVkcyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXNcbiAqIGFuZCBhcHBlbmQgY2hhcmFjdGVycyAoY29uZmlndXJhYmxlLCBkZWZhdWx0ICcuLi4nKSBpZiBzby5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2VsbGlwc2lzXSdcbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBlbGVtZW50UmVzaXplRGV0ZWN0b3I6IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyLkVyZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCB0ZXh0IChub3QgdHJ1bmNhdGVkIHlldClcbiAgICovXG4gIHByaXZhdGUgb3JpZ2luYWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZlcmVuY2VkIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBJbm5lciBkaXYgZWxlbWVudCAod2lsbCBiZSBhdXRvLWNyZWF0ZWQpXG4gICAqL1xuICBwcml2YXRlIGlubmVyRWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGxpcHNpcyBzaG91bGQgYmUgYXBwbGllZCBvbiB3aW5kb3cgcmVzaXplXG4gICAqL1xuICBwcml2YXRlIGFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcblxuICAvKipcbiAgICogUmVtb3ZlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgY2xpY2sgbGlzdGVuZXJcbiAgICogb24gdGhlIGxpbmsgYHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzYCBhcmUgd3JhcHBlZCBpbi5cbiAgICovXG4gIHByaXZhdGUgZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCB0aGlzIHdpbGwgYmUgdXNlZCBhcyBhIHN0cmluZyB0byBhcHBlbmQgdG9cbiAgICogdGhlIHRydW5jYXRlZCBjb250ZW50cy5cbiAgICogRWxzZSAnLi4uJyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcycpIGVsbGlwc2lzQ2hhcmFjdGVyczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtY29udGVudCBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBwYXNzZWQgdGhpcyBpcyB1c2VkIGFzIGNvbnRlbnQsIGVsc2UgY29udGVudHNcbiAgICogYXJlIGZldGNoZWQgZnJvbSBpbm5lckhUTUxcbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtY29udGVudCcpIGVsbGlwc2lzQ29udGVudDogc3RyaW5nID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLXdvcmQtYm91bmRhcmllcyBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIGVhY2ggY2hhcmFjdGVyIHdpbGwgYmUgaW50ZXJwcmV0ZWRcbiAgICogYXMgYSB3b3JkIGJvdW5kYXJ5IGF0IHdoaWNoIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQuXG4gICAqIEVsc2UgdGhlIHRleHQgbWF5IGJlIHRydW5jYXRlZCBhdCBhbnkgY2hhcmFjdGVyLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMnKSBlbGxpcHNpc1dvcmRCb3VuZGFyaWVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIGh0bWwgYXR0cmlidXRlXG4gICAqIEFsZ29yaXRobSB0byB1c2UgdG8gZGV0ZWN0IGVsZW1lbnQvd2luZG93IHJlc2l6ZSAtIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOiAoZGVmYXVsdCkgVXNlIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Igd2l0aCBpdHMgJ3Njcm9sbCcgc3RyYXRlZ3lcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6IFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdvYmplY3QnIHN0cmF0ZWd5IChkZXByZWNhdGVkKVxuICAgKiAnd2luZG93JzogT25seSBjaGVjayBpZiB0aGUgd2hvbGUgd2luZG93IGhhcyBiZWVuIHJlc2l6ZWQvY2hhbmdlZCBvcmllbnRhdGlvbiBieSB1c2luZyBhbmd1bGFyJ3MgYnVpbHQtaW4gSG9zdExpc3RlbmVyXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24nKSByZXNpemVEZXRlY3Rpb25TdHJhdGVneTogJycgfCAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCcgfCAnd2luZG93JztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNsaWNrLW1vcmUgaHRtbCBhdHRyaWJ1dGVcbiAgICogIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlXG4gICAqICB3cmFwcGVkIGluIDxhPjwvYT4gdGFncyBhbmQgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlXG4gICAqICBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlua1xuICAgKi9cbiAgQE91dHB1dCgnZWxsaXBzaXMtY2xpY2stbW9yZScpIG1vcmVDbGlja0VtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHRvIHF1aWNrbHkgZmluZCB0aGUgbGFyZ2VzdCBudW1iZXIgZm9yXG4gICAqIHdoaWNoIGBjYWxsYmFjayhudW1iZXIpYCBzdGlsbCByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSAgbWF4ICAgICAgSGlnaGVzdCBwb3NzaWJsZSBudW1iZXJcbiAgICogQHBhcmFtICBjYWxsYmFjayBTaG91bGQgcmV0dXJuIHRydWUgYXMgbG9uZyBhcyB0aGUgcGFzc2VkIG51bWJlciBpcyB2YWxpZFxuICAgKiBAcmV0dXJuICAgICAgICAgIExhcmdlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBudW1lcmljQmluYXJ5U2VhcmNoKG1heDogbnVtYmVyLCBjYWxsYmFjazogKG46IG51bWJlcikgPT4gYm9vbGVhbik6IG51bWJlciB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBtYXg7XG4gICAgbGV0IGJlc3QgPSAtMTtcbiAgICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICBtaWQgPSB+figobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKG1pZCk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlc3QgPSBtaWQ7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgaW5pdCB2aWV3IGxpZmUgY3ljbGUgaG9vay5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGVsZW1lbnQgZm9yIGRpc3BsYXlpbmcgdGhlIGVsbGlwc2lzLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIGxldCB0aGUgZWxsaXBzaXMgY2hhcmFjdGVycyBkZWZhdWx0IHRvICcuLi4nOlxuICAgIGlmICh0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9PT0gJycpIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gJy4uLic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPSBgPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm5neC1lbGxpcHNpcy1tb3JlXCI+JHt0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc308L2E+YDtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHJlZ2V4IHJlcGxhY2Ugb24gd29yZCBib3VuZGFyaWVzOlxuICAgIGlmICghdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPSAnJztcbiAgICB9XG4gICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJ1snICsgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpICsgJ10nO1xuXG4gICAgLy8gc3RvcmUgdGhlIG9yaWdpbmFsIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50OlxuICAgIHRoaXMuZWxlbSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGlmICh0aGlzLmVsbGlwc2lzQ29udGVudCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsbGlwc2lzQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsZW0uaW5uZXJUZXh0O1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHdyYXBwZXIgZGl2IChyZXF1aXJlZCBmb3IgcmVzaXplIGV2ZW50cyB0byB3b3JrIHByb3Blcmx5KTpcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbSwgJ2lubmVySFRNTCcsICcnKTtcbiAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmlubmVyRWxlbSwgJ25neC1lbGxpcHNpcy1pbm5lcicpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZVRleHQodGhpcy5vcmlnaW5hbFRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0sIHRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtLCB0aGlzLmlubmVyRWxlbSk7XG5cbiAgICAvLyBzdGFydCBsaXN0ZW5pbmcgZm9yIHJlc2l6ZSBldmVudHM6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcih0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgY2hhbmdlIGxpZmUgY3ljbGUgaG9vay5cbiAgICogQ2hhbmdlIG9yaWdpbmFsIHRleHQgKGlmIHRoZSBlbGxpcHNpcy1jb250ZW50IGhhcyBiZWVuIHBhc3NlZClcbiAgICogYW5kIHJlLXJlbmRlclxuICAgKi9cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgaWYgKCF0aGlzLmVsZW0gfHwgdHlwZW9mIHRoaXMuZWxsaXBzaXNDb250ZW50ID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLm9yaWdpbmFsVGV4dCA9PT0gdGhpcy5lbGxpcHNpc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsVGV4dCA9IHRoaXMuZWxsaXBzaXNDb250ZW50O1xuICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuZ3VsYXIncyBkZXN0cm95IGxpZmUgY3ljbGUgaG9vay5cbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgYWxsIHJlc2l6ZSBsaXN0ZW5lcnNcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgYSByZXNpemUgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyICh3aW5kb3cvZWxlbWVudCkgZGVwZW5kcyBvbiB0aGUgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kuXG4gICAqIEBwYXJhbSB0cmlnZ2VyTm93PWZhbHNlIGlmIHRydWUsIHRoZSBlbGxpcHNpcyBpcyBhcHBsaWVkIGltbWVkaWF0ZWx5XG4gICAqL1xuICBwcml2YXRlIGFkZFJlc2l6ZUxpc3RlbmVyKHRyaWdnZXJOb3cgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSA9ICcnO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgICAgY2FzZSAnd2luZG93JzpcbiAgICAgICAgdGhpcy5hcHBseU9uV2luZG93UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRyaWdnZXJOb3cpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZW9mIChjb25zb2xlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgTm8gc3VjaCBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIHN0cmF0ZWd5OiAnJHt0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5fScuIFVzaW5nICdlbGVtZW50LXJlc2l6ZS1kZXRlY3RvcicgaW5zdGVhZGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3dpdGNoLWNhc2UtZmFsbC10aHJvdWdoXG4gICAgICBjYXNlICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic6XG4gICAgICBjYXNlICcnOlxuICAgICAgICB0aGlzLmFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6cmVzaXplJywgWyckZXZlbnQnXSkgb25SZXNpemUoZXZlbnQ6IEV2ZW50KSB7XG4gICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUpIHtcbiAgICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGNhbGwgYXBwbHlFbGxpcHNpcygpIHdoZW5ldmVyIHRoZSBlbGVtZW50XG4gICAqIGhhcyBiZWVuIHJlc2l6ZWQuXG4gICAqIEBwYXJhbSBzY3JvbGxTdHJhdGVneT10cnVlIFVzZSB0aGUgZGVmYXVsdCBlbGVtZW50UmVzaXplRGV0ZWN0b3IncyAtIHN0cmF0ZWd5IC0gcy4gaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBhZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoc2Nyb2xsU3RyYXRlZ3kgPSB0cnVlKSB7XG4gICAgaWYgKCFFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IpIHtcbiAgICAgIGNvbnN0IG1ha2VyOiBhbnkgPSBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlcjtcbiAgICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciA9IG1ha2VyKHsgc3RyYXRlZ3k6IHNjcm9sbFN0cmF0ZWd5ID8gJ3Njcm9sbCcgOiAnb2JqZWN0JyB9KTtcbiAgICB9XG5cblxuICAgIGxldCBjYWxsZWRBc3luY2hyb25vdXNseSA9IGZhbHNlO1xuICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvci5saXN0ZW5Ubyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgKCkgPT4ge1xuICAgICAgaWYgKCFjYWxsZWRBc3luY2hyb25vdXNseSkge1xuICAgICAgICAvLyBlbGVtZW50UmVzaXplRGV0ZWN0b3IgZmlyZXMgdGhlIGV2ZW50IGRpcmVjdGx5IGFmdGVyIHJlLWF0dGFjaGluZyB0aGUgbGlzdGVuZXJcbiAgICAgICAgLy8gLT4gZGlzY2FyZCB0aGF0IGZpcnN0IGV2ZW50OlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICB9KTtcbiAgICBjYWxsZWRBc3luY2hyb25vdXNseSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGFueSByZXNpemUgZXZlbnQuXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ICE9PSAnd2luZG93Jykge1xuICAgICAgaWYgKEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciAmJiB0aGlzLmVsZW0pIHtcbiAgICAgICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yLnJlbW92ZUFsbExpc3RlbmVycyh0aGlzLmVsZW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW5hbCB0ZXh0J3MgdHJ1bmNhdGVkIHZlcnNpb24uIElmIHRoZSB0ZXh0IHJlYWxseSBuZWVkZWQgdG9cbiAgICogYmUgdHJ1bmNhdGVkLCB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgdGV4dCBtYXkgaGF2ZVxuICAgKiBAcmV0dXJuIHN0cmluZyAgICAgICB0aGUgdHJ1bmNhdGVkIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRUcnVuY2F0ZWRUZXh0KG1heDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMub3JpZ2luYWxUZXh0IHx8IHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCA8PSBtYXgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsVGV4dDtcbiAgICB9XG5cbiAgICBjb25zdCB0cnVuY2F0ZWRUZXh0ID0gdGhpcy5vcmlnaW5hbFRleHQuc3Vic3RyKDAsIG1heCk7XG4gICAgaWYgKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9PT0gJ1tdJyB8fCB0aGlzLm9yaWdpbmFsVGV4dC5jaGFyQXQobWF4KS5tYXRjaCh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpKSB7XG4gICAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dCArIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzO1xuICAgIH1cblxuICAgIGxldCBpID0gbWF4IC0gMTtcbiAgICB3aGlsZSAoaSA+IDAgJiYgIXRydW5jYXRlZFRleHQuY2hhckF0KGkpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIHRydW5jYXRlZFRleHQuc3Vic3RyKDAsIGkpICsgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cnVuY2F0ZWQgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlubmVyIGRpdlxuICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgdGV4dCBtYXkgaGF2ZVxuICAgKiBAcGFyYW0gYWRkTW9yZUxpc3RlbmVyPWZhbHNlIGxpc3RlbiBmb3IgY2xpY2sgb24gdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyBpZiB0aGUgdGV4dCBoYXMgYmVlbiB0cnVuY2F0ZWRcbiAgICovXG4gIHByaXZhdGUgdHJ1bmNhdGVUZXh0KG1heDogbnVtYmVyLCBhZGRNb3JlTGlzdGVuZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldFRydW5jYXRlZFRleHQobWF4KTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaW5uZXJFbGVtLCAnaW5uZXJIVE1MJywgdGV4dCk7XG5cbiAgICBpZiAoIWFkZE1vcmVMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgbW9yZSBjbGljayBsaXN0ZW5lcjpcbiAgICBpZiAodGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHRleHQgaGFzIGJlZW4gdHJ1bmNhdGVkLCBhZGQgYSBtb3JlIGNsaWNrIGxpc3RlbmVyOlxuICAgIGlmICh0ZXh0ICE9PSB0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmlubmVyRWxlbSwgJ2NsaWNrJywgKGU6IGFueSkgPT4ge1xuICAgICAgICBpZiAoIWUudGFyZ2V0IHx8IGUudGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ25neC1lbGxpcHNpcy1tb3JlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubW9yZUNsaWNrRW1pdHRlci5lbWl0KGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgZWxsaXBzaXMgaW4gdGhlIGlubmVyIGRpdiBpZiB0aGUgdGV4dCB3b3VsZCBleGNlZWQgdGhlIGJvdW5kYXJpZXNcbiAgICovXG4gIHByaXZhdGUgYXBwbHlFbGxpcHNpcygpIHtcbiAgICAvLyBSZW1vdmUgdGhlIHJlc2l6ZSBsaXN0ZW5lciBhcyBjaGFuZ2luZyB0aGUgY29udGFpbmVkIHRleHQgd291bGQgdHJpZ2dlciBldmVudHM6XG4gICAgdGhpcy5yZW1vdmVSZXNpemVMaXN0ZW5lcigpO1xuXG4gICAgLy8gRmluZCB0aGUgYmVzdCBsZW5ndGggYnkgdHJpYWwgYW5kIGVycm9yOlxuICAgIGNvbnN0IG1heExlbmd0aCA9IEVsbGlwc2lzRGlyZWN0aXZlLm51bWVyaWNCaW5hcnlTZWFyY2godGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoLCBjdXJMZW5ndGggPT4ge1xuICAgICAgdGhpcy50cnVuY2F0ZVRleHQoY3VyTGVuZ3RoKTtcbiAgICAgIHJldHVybiAhdGhpcy5pc092ZXJmbG93aW5nO1xuICAgIH0pO1xuXG4gICAgLy8gQXBwbHkgdGhlIGJlc3QgbGVuZ3RoOlxuICAgIHRoaXMudHJ1bmNhdGVUZXh0KG1heExlbmd0aCwgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkpO1xuXG4gICAgLy8gUmUtYXR0YWNoIHRoZSByZXNpemUgbGlzdGVuZXI6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcigpO1xuICB9XG5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgdGV4dCBpcyBleGNlZWRpbmcgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgaXNPdmVyZmxvd2luZygpOiBib29sZWFuIHtcbiAgICAvLyBFbmZvcmNlIGhpZGRlbiBvdmVyZmxvdyAocmVxdWlyZWQgdG8gY29tcGFyZSBjbGllbnQgd2lkdGgvaGVpZ2h0IHdpdGggc2Nyb2xsIHdpZHRoL2hlaWdodClcbiAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3cgPSB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3c7XG4gICAgaWYgKCFjdXJyZW50T3ZlcmZsb3cgfHwgY3VycmVudE92ZXJmbG93ID09PSAndmlzaWJsZScpIHtcbiAgICAgIHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIGNvbnN0IGlzT3ZlcmZsb3dpbmcgPSB0aGlzLmVsZW0uY2xpZW50V2lkdGggPCB0aGlzLmVsZW0uc2Nyb2xsV2lkdGggLSAxIHx8IHRoaXMuZWxlbS5jbGllbnRIZWlnaHQgPCB0aGlzLmVsZW0uc2Nyb2xsSGVpZ2h0IC0gMTtcblxuICAgIC8vIFJlc2V0IG92ZXJmbG93IHRvIHRoZSBvcmlnaW5hbCBjb25maWd1cmF0aW9uOlxuICAgIHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdyA9IGN1cnJlbnRPdmVyZmxvdztcblxuICAgIHJldHVybiBpc092ZXJmbG93aW5nO1xuICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRWxsaXBzaXNEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtFbGxpcHNpc0RpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtFbGxpcHNpc0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNNb2R1bGUgeyB9XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7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