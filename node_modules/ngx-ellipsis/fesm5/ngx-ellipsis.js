import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, HostListener, NgModule } from '@angular/core';
import * as elementResizeDetectorMaker from 'element-resize-detector';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
var EllipsisDirective = /** @class */ (function () {
    function EllipsisDirective(elementRef, renderer, ngZone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Whether the ellipsis should be applied on window resize
         */
        this.applyOnWindowResize = false;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from innerHTML
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         *  If anything is passed, the ellipsisCharacters will be
         *  wrapped in <a></a> tags and an event handler for the
         *  passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    EllipsisDirective.numericBinarySearch = /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    function (max, callback) {
        /** @type {?} */
        var low = 0;
        /** @type {?} */
        var high = max;
        /** @type {?} */
        var best = -1;
        /** @type {?} */
        var mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            /** @type {?} */
            var result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    };
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     */
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    EllipsisDirective.prototype.ngAfterViewInit = /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    function () {
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        if (this.moreClickEmitter.observers.length > 0) {
            this.ellipsisCharacters = "<a href=\"#\" class=\"ngx-ellipsis-more\">" + this.ellipsisCharacters + "</a>";
        }
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (this.ellipsisContent) {
            this.originalText = this.ellipsisContent;
        }
        else if (!this.originalText) {
            this.originalText = this.elem.innerText;
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        /** @type {?} */
        var text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    };
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     */
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    EllipsisDirective.prototype.ngOnChanges = /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    function () {
        if (!this.elem || typeof this.ellipsisContent === 'undefined' || this.originalText === this.ellipsisContent) {
            return;
        }
        this.originalText = this.ellipsisContent;
        this.applyEllipsis();
    };
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     */
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    EllipsisDirective.prototype.ngOnDestroy = /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    function () {
        this.removeAllListeners();
    };
    /**
     * remove all resize listeners
     * @return {?}
     */
    EllipsisDirective.prototype.removeAllListeners = /**
     * remove all resize listeners
     * @return {?}
     */
    function () {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    };
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    EllipsisDirective.prototype.addResizeListener = /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    function (triggerNow) {
        if (triggerNow === void 0) { triggerNow = false; }
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'window':
                this.applyOnWindowResize = true;
                if (triggerNow) {
                    this.applyEllipsis();
                }
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn("No such ellipsis-resize-detection strategy: '" + this.resizeDetectionStrategy + "'. Using 'element-resize-detector' instead");
                }
            // tslint:disable-next-line:no-switch-case-fall-through
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    EllipsisDirective.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.ngZone.run(function () {
            if (_this.applyOnWindowResize) {
                _this.applyEllipsis();
            }
        });
    };
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    EllipsisDirective.prototype.addElementResizeListener = /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    function (scrollStrategy) {
        var _this = this;
        if (scrollStrategy === void 0) { scrollStrategy = true; }
        if (!EllipsisDirective.elementResizeDetector) {
            /** @type {?} */
            var maker = elementResizeDetectorMaker;
            EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        /** @type {?} */
        var calledAsynchronously = false;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, function () {
            if (!calledAsynchronously) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                return;
            }
            _this.applyEllipsis();
        });
        calledAsynchronously = true;
    };
    /**
     * Stop listening for any resize event.
     * @return {?}
     */
    EllipsisDirective.prototype.removeResizeListener = /**
     * Stop listening for any resize event.
     * @return {?}
     */
    function () {
        if (this.resizeDetectionStrategy !== 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.applyOnWindowResize = false;
        }
    };
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    EllipsisDirective.prototype.getTruncatedText = /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    function (max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        /** @type {?} */
        var truncatedText = this.originalText.substr(0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText + this.ellipsisCharacters;
        }
        /** @type {?} */
        var i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return truncatedText.substr(0, i) + this.ellipsisCharacters;
    };
    /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    EllipsisDirective.prototype.truncateText = /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    function (max, addMoreListener) {
        var _this = this;
        if (addMoreListener === void 0) { addMoreListener = false; }
        /** @type {?} */
        var text = this.getTruncatedText(max);
        this.renderer.setProperty(this.innerElem, 'innerHTML', text);
        if (!addMoreListener) {
            return;
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        // If the text has been truncated, add a more click listener:
        if (text !== this.originalText) {
            this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', function (e) {
                if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                _this.moreClickEmitter.emit(e);
            });
        }
    };
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    EllipsisDirective.prototype.applyEllipsis = /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    function () {
        var _this = this;
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        /** @type {?} */
        var maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, function (curLength) {
            _this.truncateText(curLength);
            return !_this.isOverflowing;
        });
        // Apply the best length:
        this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
        // Re-attach the resize listener:
        this.addResizeListener();
    };
    Object.defineProperty(EllipsisDirective.prototype, "isOverflowing", {
        get: /**
         * Whether the text is exceeding the element's boundaries or not
         * @return {?}
         */
        function () {
            /** @type {?} */
            var currentOverflow = this.elem.style.overflow;
            if (!currentOverflow || currentOverflow === 'visible') {
                this.elem.style.overflow = 'hidden';
            }
            /** @type {?} */
            var isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
            // Reset overflow to the original configuration:
            this.elem.style.overflow = currentOverflow;
            return isOverflowing;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Instance of https://github.com/wnr/element-resize-detector
     */
    EllipsisDirective.elementResizeDetector = null;
    EllipsisDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ellipsis]'
                },] },
    ];
    /** @nocollapse */
    EllipsisDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    EllipsisDirective.propDecorators = {
        ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
        ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
        ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
        resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
        moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return EllipsisDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var EllipsisModule = /** @class */ (function () {
    function EllipsisModule() {
    }
    EllipsisModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [EllipsisDirective],
                    exports: [EllipsisDirective]
                },] },
    ];
    return EllipsisModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { EllipsisDirective, EllipsisModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWVsbGlwc2lzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtZWxsaXBzaXMvbGliL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtZWxsaXBzaXMvbGliL2VsbGlwc2lzLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIFJlbmRlcmVyMixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBOZ1pvbmUsXG4gIEhvc3RMaXN0ZW5lcixcbiAgT25DaGFuZ2VzLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlciBmcm9tICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIHRydW5jYXRlIHRoZSBjb250YWluZWQgdGV4dCwgaWYgaXQgZXhjZWVkcyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXNcbiAqIGFuZCBhcHBlbmQgY2hhcmFjdGVycyAoY29uZmlndXJhYmxlLCBkZWZhdWx0ICcuLi4nKSBpZiBzby5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2VsbGlwc2lzXSdcbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBlbGVtZW50UmVzaXplRGV0ZWN0b3I6IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyLkVyZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCB0ZXh0IChub3QgdHJ1bmNhdGVkIHlldClcbiAgICovXG4gIHByaXZhdGUgb3JpZ2luYWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZlcmVuY2VkIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBJbm5lciBkaXYgZWxlbWVudCAod2lsbCBiZSBhdXRvLWNyZWF0ZWQpXG4gICAqL1xuICBwcml2YXRlIGlubmVyRWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGxpcHNpcyBzaG91bGQgYmUgYXBwbGllZCBvbiB3aW5kb3cgcmVzaXplXG4gICAqL1xuICBwcml2YXRlIGFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcblxuICAvKipcbiAgICogUmVtb3ZlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgY2xpY2sgbGlzdGVuZXJcbiAgICogb24gdGhlIGxpbmsgYHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzYCBhcmUgd3JhcHBlZCBpbi5cbiAgICovXG4gIHByaXZhdGUgZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCB0aGlzIHdpbGwgYmUgdXNlZCBhcyBhIHN0cmluZyB0byBhcHBlbmQgdG9cbiAgICogdGhlIHRydW5jYXRlZCBjb250ZW50cy5cbiAgICogRWxzZSAnLi4uJyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcycpIGVsbGlwc2lzQ2hhcmFjdGVyczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtY29udGVudCBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBwYXNzZWQgdGhpcyBpcyB1c2VkIGFzIGNvbnRlbnQsIGVsc2UgY29udGVudHNcbiAgICogYXJlIGZldGNoZWQgZnJvbSBpbm5lckhUTUxcbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtY29udGVudCcpIGVsbGlwc2lzQ29udGVudDogc3RyaW5nID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLXdvcmQtYm91bmRhcmllcyBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIGVhY2ggY2hhcmFjdGVyIHdpbGwgYmUgaW50ZXJwcmV0ZWRcbiAgICogYXMgYSB3b3JkIGJvdW5kYXJ5IGF0IHdoaWNoIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQuXG4gICAqIEVsc2UgdGhlIHRleHQgbWF5IGJlIHRydW5jYXRlZCBhdCBhbnkgY2hhcmFjdGVyLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMnKSBlbGxpcHNpc1dvcmRCb3VuZGFyaWVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIGh0bWwgYXR0cmlidXRlXG4gICAqIEFsZ29yaXRobSB0byB1c2UgdG8gZGV0ZWN0IGVsZW1lbnQvd2luZG93IHJlc2l6ZSAtIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOiAoZGVmYXVsdCkgVXNlIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Igd2l0aCBpdHMgJ3Njcm9sbCcgc3RyYXRlZ3lcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6IFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdvYmplY3QnIHN0cmF0ZWd5IChkZXByZWNhdGVkKVxuICAgKiAnd2luZG93JzogT25seSBjaGVjayBpZiB0aGUgd2hvbGUgd2luZG93IGhhcyBiZWVuIHJlc2l6ZWQvY2hhbmdlZCBvcmllbnRhdGlvbiBieSB1c2luZyBhbmd1bGFyJ3MgYnVpbHQtaW4gSG9zdExpc3RlbmVyXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24nKSByZXNpemVEZXRlY3Rpb25TdHJhdGVneTogJycgfCAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCcgfCAnd2luZG93JztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNsaWNrLW1vcmUgaHRtbCBhdHRyaWJ1dGVcbiAgICogIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlXG4gICAqICB3cmFwcGVkIGluIDxhPjwvYT4gdGFncyBhbmQgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlXG4gICAqICBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlua1xuICAgKi9cbiAgQE91dHB1dCgnZWxsaXBzaXMtY2xpY2stbW9yZScpIG1vcmVDbGlja0VtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHRvIHF1aWNrbHkgZmluZCB0aGUgbGFyZ2VzdCBudW1iZXIgZm9yXG4gICAqIHdoaWNoIGBjYWxsYmFjayhudW1iZXIpYCBzdGlsbCByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSAgbWF4ICAgICAgSGlnaGVzdCBwb3NzaWJsZSBudW1iZXJcbiAgICogQHBhcmFtICBjYWxsYmFjayBTaG91bGQgcmV0dXJuIHRydWUgYXMgbG9uZyBhcyB0aGUgcGFzc2VkIG51bWJlciBpcyB2YWxpZFxuICAgKiBAcmV0dXJuICAgICAgICAgIExhcmdlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBudW1lcmljQmluYXJ5U2VhcmNoKG1heDogbnVtYmVyLCBjYWxsYmFjazogKG46IG51bWJlcikgPT4gYm9vbGVhbik6IG51bWJlciB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBtYXg7XG4gICAgbGV0IGJlc3QgPSAtMTtcbiAgICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICBtaWQgPSB+figobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKG1pZCk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlc3QgPSBtaWQ7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgaW5pdCB2aWV3IGxpZmUgY3ljbGUgaG9vay5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGVsZW1lbnQgZm9yIGRpc3BsYXlpbmcgdGhlIGVsbGlwc2lzLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIGxldCB0aGUgZWxsaXBzaXMgY2hhcmFjdGVycyBkZWZhdWx0IHRvICcuLi4nOlxuICAgIGlmICh0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9PT0gJycpIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gJy4uLic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPSBgPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm5neC1lbGxpcHNpcy1tb3JlXCI+JHt0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc308L2E+YDtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHJlZ2V4IHJlcGxhY2Ugb24gd29yZCBib3VuZGFyaWVzOlxuICAgIGlmICghdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPSAnJztcbiAgICB9XG4gICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJ1snICsgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpICsgJ10nO1xuXG4gICAgLy8gc3RvcmUgdGhlIG9yaWdpbmFsIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50OlxuICAgIHRoaXMuZWxlbSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGlmICh0aGlzLmVsbGlwc2lzQ29udGVudCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsbGlwc2lzQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsZW0uaW5uZXJUZXh0O1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHdyYXBwZXIgZGl2IChyZXF1aXJlZCBmb3IgcmVzaXplIGV2ZW50cyB0byB3b3JrIHByb3Blcmx5KTpcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbSwgJ2lubmVySFRNTCcsICcnKTtcbiAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmlubmVyRWxlbSwgJ25neC1lbGxpcHNpcy1pbm5lcicpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZVRleHQodGhpcy5vcmlnaW5hbFRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0sIHRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtLCB0aGlzLmlubmVyRWxlbSk7XG5cbiAgICAvLyBzdGFydCBsaXN0ZW5pbmcgZm9yIHJlc2l6ZSBldmVudHM6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcih0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgY2hhbmdlIGxpZmUgY3ljbGUgaG9vay5cbiAgICogQ2hhbmdlIG9yaWdpbmFsIHRleHQgKGlmIHRoZSBlbGxpcHNpcy1jb250ZW50IGhhcyBiZWVuIHBhc3NlZClcbiAgICogYW5kIHJlLXJlbmRlclxuICAgKi9cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgaWYgKCF0aGlzLmVsZW0gfHwgdHlwZW9mIHRoaXMuZWxsaXBzaXNDb250ZW50ID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLm9yaWdpbmFsVGV4dCA9PT0gdGhpcy5lbGxpcHNpc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsVGV4dCA9IHRoaXMuZWxsaXBzaXNDb250ZW50O1xuICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuZ3VsYXIncyBkZXN0cm95IGxpZmUgY3ljbGUgaG9vay5cbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgYWxsIHJlc2l6ZSBsaXN0ZW5lcnNcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgYSByZXNpemUgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyICh3aW5kb3cvZWxlbWVudCkgZGVwZW5kcyBvbiB0aGUgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kuXG4gICAqIEBwYXJhbSB0cmlnZ2VyTm93PWZhbHNlIGlmIHRydWUsIHRoZSBlbGxpcHNpcyBpcyBhcHBsaWVkIGltbWVkaWF0ZWx5XG4gICAqL1xuICBwcml2YXRlIGFkZFJlc2l6ZUxpc3RlbmVyKHRyaWdnZXJOb3cgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSA9ICcnO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgICAgY2FzZSAnd2luZG93JzpcbiAgICAgICAgdGhpcy5hcHBseU9uV2luZG93UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRyaWdnZXJOb3cpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZW9mIChjb25zb2xlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgTm8gc3VjaCBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIHN0cmF0ZWd5OiAnJHt0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5fScuIFVzaW5nICdlbGVtZW50LXJlc2l6ZS1kZXRlY3RvcicgaW5zdGVhZGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3dpdGNoLWNhc2UtZmFsbC10aHJvdWdoXG4gICAgICBjYXNlICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic6XG4gICAgICBjYXNlICcnOlxuICAgICAgICB0aGlzLmFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6cmVzaXplJywgWyckZXZlbnQnXSkgb25SZXNpemUoZXZlbnQ6IEV2ZW50KSB7XG4gICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUpIHtcbiAgICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGNhbGwgYXBwbHlFbGxpcHNpcygpIHdoZW5ldmVyIHRoZSBlbGVtZW50XG4gICAqIGhhcyBiZWVuIHJlc2l6ZWQuXG4gICAqIEBwYXJhbSBzY3JvbGxTdHJhdGVneT10cnVlIFVzZSB0aGUgZGVmYXVsdCBlbGVtZW50UmVzaXplRGV0ZWN0b3IncyAtIHN0cmF0ZWd5IC0gcy4gaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBhZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoc2Nyb2xsU3RyYXRlZ3kgPSB0cnVlKSB7XG4gICAgaWYgKCFFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IpIHtcbiAgICAgIGNvbnN0IG1ha2VyOiBhbnkgPSBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlcjtcbiAgICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciA9IG1ha2VyKHsgc3RyYXRlZ3k6IHNjcm9sbFN0cmF0ZWd5ID8gJ3Njcm9sbCcgOiAnb2JqZWN0JyB9KTtcbiAgICB9XG5cblxuICAgIGxldCBjYWxsZWRBc3luY2hyb25vdXNseSA9IGZhbHNlO1xuICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvci5saXN0ZW5Ubyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgKCkgPT4ge1xuICAgICAgaWYgKCFjYWxsZWRBc3luY2hyb25vdXNseSkge1xuICAgICAgICAvLyBlbGVtZW50UmVzaXplRGV0ZWN0b3IgZmlyZXMgdGhlIGV2ZW50IGRpcmVjdGx5IGFmdGVyIHJlLWF0dGFjaGluZyB0aGUgbGlzdGVuZXJcbiAgICAgICAgLy8gLT4gZGlzY2FyZCB0aGF0IGZpcnN0IGV2ZW50OlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICB9KTtcbiAgICBjYWxsZWRBc3luY2hyb25vdXNseSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGFueSByZXNpemUgZXZlbnQuXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ICE9PSAnd2luZG93Jykge1xuICAgICAgaWYgKEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciAmJiB0aGlzLmVsZW0pIHtcbiAgICAgICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yLnJlbW92ZUFsbExpc3RlbmVycyh0aGlzLmVsZW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW5hbCB0ZXh0J3MgdHJ1bmNhdGVkIHZlcnNpb24uIElmIHRoZSB0ZXh0IHJlYWxseSBuZWVkZWQgdG9cbiAgICogYmUgdHJ1bmNhdGVkLCB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgdGV4dCBtYXkgaGF2ZVxuICAgKiBAcmV0dXJuIHN0cmluZyAgICAgICB0aGUgdHJ1bmNhdGVkIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRUcnVuY2F0ZWRUZXh0KG1heDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMub3JpZ2luYWxUZXh0IHx8IHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCA8PSBtYXgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsVGV4dDtcbiAgICB9XG5cbiAgICBjb25zdCB0cnVuY2F0ZWRUZXh0ID0gdGhpcy5vcmlnaW5hbFRleHQuc3Vic3RyKDAsIG1heCk7XG4gICAgaWYgKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9PT0gJ1tdJyB8fCB0aGlzLm9yaWdpbmFsVGV4dC5jaGFyQXQobWF4KS5tYXRjaCh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpKSB7XG4gICAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dCArIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzO1xuICAgIH1cblxuICAgIGxldCBpID0gbWF4IC0gMTtcbiAgICB3aGlsZSAoaSA+IDAgJiYgIXRydW5jYXRlZFRleHQuY2hhckF0KGkpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIHRydW5jYXRlZFRleHQuc3Vic3RyKDAsIGkpICsgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cnVuY2F0ZWQgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlubmVyIGRpdlxuICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgdGV4dCBtYXkgaGF2ZVxuICAgKiBAcGFyYW0gYWRkTW9yZUxpc3RlbmVyPWZhbHNlIGxpc3RlbiBmb3IgY2xpY2sgb24gdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyBpZiB0aGUgdGV4dCBoYXMgYmVlbiB0cnVuY2F0ZWRcbiAgICovXG4gIHByaXZhdGUgdHJ1bmNhdGVUZXh0KG1heDogbnVtYmVyLCBhZGRNb3JlTGlzdGVuZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldFRydW5jYXRlZFRleHQobWF4KTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaW5uZXJFbGVtLCAnaW5uZXJIVE1MJywgdGV4dCk7XG5cbiAgICBpZiAoIWFkZE1vcmVMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgbW9yZSBjbGljayBsaXN0ZW5lcjpcbiAgICBpZiAodGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHRleHQgaGFzIGJlZW4gdHJ1bmNhdGVkLCBhZGQgYSBtb3JlIGNsaWNrIGxpc3RlbmVyOlxuICAgIGlmICh0ZXh0ICE9PSB0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmlubmVyRWxlbSwgJ2NsaWNrJywgKGU6IGFueSkgPT4ge1xuICAgICAgICBpZiAoIWUudGFyZ2V0IHx8IGUudGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ25neC1lbGxpcHNpcy1tb3JlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubW9yZUNsaWNrRW1pdHRlci5lbWl0KGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgZWxsaXBzaXMgaW4gdGhlIGlubmVyIGRpdiBpZiB0aGUgdGV4dCB3b3VsZCBleGNlZWQgdGhlIGJvdW5kYXJpZXNcbiAgICovXG4gIHByaXZhdGUgYXBwbHlFbGxpcHNpcygpIHtcbiAgICAvLyBSZW1vdmUgdGhlIHJlc2l6ZSBsaXN0ZW5lciBhcyBjaGFuZ2luZyB0aGUgY29udGFpbmVkIHRleHQgd291bGQgdHJpZ2dlciBldmVudHM6XG4gICAgdGhpcy5yZW1vdmVSZXNpemVMaXN0ZW5lcigpO1xuXG4gICAgLy8gRmluZCB0aGUgYmVzdCBsZW5ndGggYnkgdHJpYWwgYW5kIGVycm9yOlxuICAgIGNvbnN0IG1heExlbmd0aCA9IEVsbGlwc2lzRGlyZWN0aXZlLm51bWVyaWNCaW5hcnlTZWFyY2godGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoLCBjdXJMZW5ndGggPT4ge1xuICAgICAgdGhpcy50cnVuY2F0ZVRleHQoY3VyTGVuZ3RoKTtcbiAgICAgIHJldHVybiAhdGhpcy5pc092ZXJmbG93aW5nO1xuICAgIH0pO1xuXG4gICAgLy8gQXBwbHkgdGhlIGJlc3QgbGVuZ3RoOlxuICAgIHRoaXMudHJ1bmNhdGVUZXh0KG1heExlbmd0aCwgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkpO1xuXG4gICAgLy8gUmUtYXR0YWNoIHRoZSByZXNpemUgbGlzdGVuZXI6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcigpO1xuICB9XG5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgdGV4dCBpcyBleGNlZWRpbmcgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgaXNPdmVyZmxvd2luZygpOiBib29sZWFuIHtcbiAgICAvLyBFbmZvcmNlIGhpZGRlbiBvdmVyZmxvdyAocmVxdWlyZWQgdG8gY29tcGFyZSBjbGllbnQgd2lkdGgvaGVpZ2h0IHdpdGggc2Nyb2xsIHdpZHRoL2hlaWdodClcbiAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3cgPSB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3c7XG4gICAgaWYgKCFjdXJyZW50T3ZlcmZsb3cgfHwgY3VycmVudE92ZXJmbG93ID09PSAndmlzaWJsZScpIHtcbiAgICAgIHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIGNvbnN0IGlzT3ZlcmZsb3dpbmcgPSB0aGlzLmVsZW0uY2xpZW50V2lkdGggPCB0aGlzLmVsZW0uc2Nyb2xsV2lkdGggLSAxIHx8IHRoaXMuZWxlbS5jbGllbnRIZWlnaHQgPCB0aGlzLmVsZW0uc2Nyb2xsSGVpZ2h0IC0gMTtcblxuICAgIC8vIFJlc2V0IG92ZXJmbG93IHRvIHRoZSBvcmlnaW5hbCBjb25maWd1cmF0aW9uOlxuICAgIHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdyA9IGN1cnJlbnRPdmVyZmxvdztcblxuICAgIHJldHVybiBpc092ZXJmbG93aW5nO1xuICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRWxsaXBzaXNEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtFbGxpcHNpc0RpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtFbGxpcHNpc0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNNb2R1bGUgeyB9XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7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