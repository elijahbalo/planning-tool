/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, HostListener } from '@angular/core';
import * as elementResizeDetectorMaker from 'element-resize-detector';
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
export class EllipsisDirective {
    /**
     * The directive's constructor
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(elementRef, renderer, ngZone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Whether the ellipsis should be applied on window resize
         */
        this.applyOnWindowResize = false;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from innerHTML
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         *  If anything is passed, the ellipsisCharacters will be
         *  wrapped in <a></a> tags and an event handler for the
         *  passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    static numericBinarySearch(max, callback) {
        /** @type {?} */
        let low = 0;
        /** @type {?} */
        let high = max;
        /** @type {?} */
        let best = -1;
        /** @type {?} */
        let mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            /** @type {?} */
            const result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    }
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    ngAfterViewInit() {
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        if (this.moreClickEmitter.observers.length > 0) {
            this.ellipsisCharacters = `<a href="#" class="ngx-ellipsis-more">${this.ellipsisCharacters}</a>`;
        }
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (this.ellipsisContent) {
            this.originalText = this.ellipsisContent;
        }
        else if (!this.originalText) {
            this.originalText = this.elem.innerText;
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        /** @type {?} */
        const text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    }
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    ngOnChanges() {
        if (!this.elem || typeof this.ellipsisContent === 'undefined' || this.originalText === this.ellipsisContent) {
            return;
        }
        this.originalText = this.ellipsisContent;
        this.applyEllipsis();
    }
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    ngOnDestroy() {
        this.removeAllListeners();
    }
    /**
     * remove all resize listeners
     * @return {?}
     */
    removeAllListeners() {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    addResizeListener(triggerNow = false) {
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'window':
                this.applyOnWindowResize = true;
                if (triggerNow) {
                    this.applyEllipsis();
                }
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn(`No such ellipsis-resize-detection strategy: '${this.resizeDetectionStrategy}'. Using 'element-resize-detector' instead`);
                }
            // tslint:disable-next-line:no-switch-case-fall-through
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.ngZone.run(() => {
            if (this.applyOnWindowResize) {
                this.applyEllipsis();
            }
        });
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    addElementResizeListener(scrollStrategy = true) {
        if (!EllipsisDirective.elementResizeDetector) {
            /** @type {?} */
            const maker = elementResizeDetectorMaker;
            EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        /** @type {?} */
        let calledAsynchronously = false;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, () => {
            if (!calledAsynchronously) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                return;
            }
            this.applyEllipsis();
        });
        calledAsynchronously = true;
    }
    /**
     * Stop listening for any resize event.
     * @return {?}
     */
    removeResizeListener() {
        if (this.resizeDetectionStrategy !== 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.applyOnWindowResize = false;
        }
    }
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    getTruncatedText(max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        /** @type {?} */
        const truncatedText = this.originalText.substr(0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText + this.ellipsisCharacters;
        }
        /** @type {?} */
        let i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return truncatedText.substr(0, i) + this.ellipsisCharacters;
    }
    /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    truncateText(max, addMoreListener = false) {
        /** @type {?} */
        const text = this.getTruncatedText(max);
        this.renderer.setProperty(this.innerElem, 'innerHTML', text);
        if (!addMoreListener) {
            return;
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        // If the text has been truncated, add a more click listener:
        if (text !== this.originalText) {
            this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', (e) => {
                if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                this.moreClickEmitter.emit(e);
            });
        }
    }
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    applyEllipsis() {
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        /** @type {?} */
        const maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, curLength => {
            this.truncateText(curLength);
            return !this.isOverflowing;
        });
        // Apply the best length:
        this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
        // Re-attach the resize listener:
        this.addResizeListener();
    }
    /**
     * Whether the text is exceeding the element's boundaries or not
     * @return {?}
     */
    get isOverflowing() {
        /** @type {?} */
        const currentOverflow = this.elem.style.overflow;
        if (!currentOverflow || currentOverflow === 'visible') {
            this.elem.style.overflow = 'hidden';
        }
        /** @type {?} */
        const isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
        // Reset overflow to the original configuration:
        this.elem.style.overflow = currentOverflow;
        return isOverflowing;
    }
}
/**
 * Instance of https://github.com/wnr/element-resize-detector
 */
EllipsisDirective.elementResizeDetector = null;
EllipsisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ellipsis]'
            },] },
];
/** @nocollapse */
EllipsisDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
EllipsisDirective.propDecorators = {
    ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
    ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
    ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
    resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
    moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * Instance of https://github.com/wnr/element-resize-detector
     * @type {?}
     */
    EllipsisDirective.elementResizeDetector;
    /**
     * The original text (not truncated yet)
     * @type {?}
     */
    EllipsisDirective.prototype.originalText;
    /**
     * The referenced element
     * @type {?}
     */
    EllipsisDirective.prototype.elem;
    /**
     * Inner div element (will be auto-created)
     * @type {?}
     */
    EllipsisDirective.prototype.innerElem;
    /**
     * Whether the ellipsis should be applied on window resize
     * @type {?}
     */
    EllipsisDirective.prototype.applyOnWindowResize;
    /**
     * Remove function for the currently registered click listener
     * on the link `this.ellipsisCharacters` are wrapped in.
     * @type {?}
     */
    EllipsisDirective.prototype.destroyMoreClickListener;
    /**
     * The ellipsis html attribute
     * If anything is passed, this will be used as a string to append to
     * the truncated contents.
     * Else '...' will be appended.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisCharacters;
    /**
     * The ellipsis-content html attribute
     * If passed this is used as content, else contents
     * are fetched from innerHTML
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisContent;
    /**
     * The ellipsis-word-boundaries html attribute
     * If anything is passed, each character will be interpreted
     * as a word boundary at which the text may be truncated.
     * Else the text may be truncated at any character.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisWordBoundaries;
    /**
     * The ellipsis-resize-detection html attribute
     * Algorithm to use to detect element/window resize - any of the following:
     * 'element-resize-detector': (default) Use https://github.com/wnr/element-resize-detector with its 'scroll' strategy
     * 'element-resize-detector-object': Use https://github.com/wnr/element-resize-detector with its 'object' strategy (deprecated)
     * 'window': Only check if the whole window has been resized/changed orientation by using angular's built-in HostListener
     * @type {?}
     */
    EllipsisDirective.prototype.resizeDetectionStrategy;
    /**
     * The ellipsis-click-more html attribute
     *  If anything is passed, the ellipsisCharacters will be
     *  wrapped in <a></a> tags and an event handler for the
     *  passed function will be added to the link
     * @type {?}
     */
    EllipsisDirective.prototype.moreClickEmitter;
    /** @type {?} */
    EllipsisDirective.prototype.elementRef;
    /** @type {?} */
    EllipsisDirective.prototype.renderer;
    /** @type {?} */
    EllipsisDirective.prototype.ngZone;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxsaXBzaXMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWVsbGlwc2lzLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osTUFBTSxFQUNOLFlBQVksRUFJYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEtBQUssMEJBQTBCLE1BQU0seUJBQXlCLENBQUM7Ozs7O0FBU3RFLE1BQU07Ozs7Ozs7Z0JBd0d1QixVQUFzQixFQUFVLFFBQW1CLEVBQVUsTUFBYztRQUEzRSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUFVLFdBQU0sR0FBTixNQUFNLENBQVE7Ozs7bUNBaEZ4RSxLQUFLOzs7Ozs7K0JBcUJrQixJQUFJOzs7Ozs7O2dDQXlCWSxJQUFJLFlBQVksRUFBRTs7Ozs7Ozs7O0lBVS9FLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxHQUFXLEVBQUUsUUFBZ0M7O1FBQzlFLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQzs7UUFDWixJQUFJLElBQUksR0FBRyxHQUFHLENBQUM7O1FBQ2YsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7O1FBQ2QsSUFBSSxHQUFHLENBQVM7UUFFaEIsT0FBTyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7O1lBRW5CLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7WUFDM0IsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzdCLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDWixJQUFJLEdBQUcsR0FBRyxH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QUV2QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUM7UUFDakQsRUFBRSxDQUFDLENBQUMsQ0FBQyxlQUFlLElBQUksZUFBZSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdEQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztTQUNyQzs7UUFFRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDOztRQUcvSCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsZUFBZSxDQUFDO1FBRTNDLE1BQU0sQ0FBQyxhQUFhLENBQUM7Ozs7OzswQ0F4VmdELElBQUk7O1lBUDVFLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsWUFBWTthQUN2Qjs7OztZQW5CQyxVQUFVO1lBQ1YsU0FBUztZQUlULE1BQU07OztpQ0FxREwsS0FBSyxTQUFDLFVBQVU7OEJBT2hCLEtBQUssU0FBQyxrQkFBa0I7cUNBUXhCLEtBQUssU0FBQywwQkFBMEI7c0NBU2hDLEtBQUssU0FBQywyQkFBMkI7K0JBUWpDLE1BQU0sU0FBQyxxQkFBcUI7dUJBZ0o1QixZQUFZLFNBQUMsZUFBZSxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBSZW5kZXJlcjIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgTmdab25lLFxuICBIb3N0TGlzdGVuZXIsXG4gIE9uQ2hhbmdlcyxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIgZnJvbSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIERpcmVjdGl2ZSB0byB0cnVuY2F0ZSB0aGUgY29udGFpbmVkIHRleHQsIGlmIGl0IGV4Y2VlZHMgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzXG4gKiBhbmQgYXBwZW5kIGNoYXJhY3RlcnMgKGNvbmZpZ3VyYWJsZSwgZGVmYXVsdCAnLi4uJykgaWYgc28uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlbGxpcHNpc10nXG59KVxuZXhwb3J0IGNsYXNzIEVsbGlwc2lzRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZWxlbWVudFJlc2l6ZURldGVjdG9yOiBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlci5FcmQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgdGV4dCAobm90IHRydW5jYXRlZCB5ZXQpXG4gICAqL1xuICBwcml2YXRlIG9yaWdpbmFsVGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVmZXJlbmNlZCBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIGVsZW06IGFueTtcblxuICAvKipcbiAgICogSW5uZXIgZGl2IGVsZW1lbnQgKHdpbGwgYmUgYXV0by1jcmVhdGVkKVxuICAgKi9cbiAgcHJpdmF0ZSBpbm5lckVsZW06IGFueTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZWxsaXBzaXMgc2hvdWxkIGJlIGFwcGxpZWQgb24gd2luZG93IHJlc2l6ZVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseU9uV2luZG93UmVzaXplID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGNsaWNrIGxpc3RlbmVyXG4gICAqIG9uIHRoZSBsaW5rIGB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc2AgYXJlIHdyYXBwZWQgaW4uXG4gICAqL1xuICBwcml2YXRlIGRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzIGh0bWwgYXR0cmlidXRlXG4gICAqIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhpcyB3aWxsIGJlIHVzZWQgYXMgYSBzdHJpbmcgdG8gYXBwZW5kIHRvXG4gICAqIHRoZSB0cnVuY2F0ZWQgY29udGVudHMuXG4gICAqIEVsc2UgJy4uLicgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMnKSBlbGxpcHNpc0NoYXJhY3RlcnM6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNvbnRlbnQgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgcGFzc2VkIHRoaXMgaXMgdXNlZCBhcyBjb250ZW50LCBlbHNlIGNvbnRlbnRzXG4gICAqIGFyZSBmZXRjaGVkIGZyb20gaW5uZXJIVE1MXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLWNvbnRlbnQnKSBlbGxpcHNpc0NvbnRlbnQ6IHN0cmluZyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCBlYWNoIGNoYXJhY3RlciB3aWxsIGJlIGludGVycHJldGVkXG4gICAqIGFzIGEgd29yZCBib3VuZGFyeSBhdCB3aGljaCB0aGUgdGV4dCBtYXkgYmUgdHJ1bmNhdGVkLlxuICAgKiBFbHNlIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQgYXQgYW55IGNoYXJhY3Rlci5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtd29yZC1ib3VuZGFyaWVzJykgZWxsaXBzaXNXb3JkQm91bmRhcmllczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtcmVzaXplLWRldGVjdGlvbiBodG1sIGF0dHJpYnV0ZVxuICAgKiBBbGdvcml0aG0gdG8gdXNlIHRvIGRldGVjdCBlbGVtZW50L3dpbmRvdyByZXNpemUgLSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzogKGRlZmF1bHQpIFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdzY3JvbGwnIHN0cmF0ZWd5XG4gICAqICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnOiBVc2UgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvciB3aXRoIGl0cyAnb2JqZWN0JyBzdHJhdGVneSAoZGVwcmVjYXRlZClcbiAgICogJ3dpbmRvdyc6IE9ubHkgY2hlY2sgaWYgdGhlIHdob2xlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkL2NoYW5nZWQgb3JpZW50YXRpb24gYnkgdXNpbmcgYW5ndWxhcidzIGJ1aWx0LWluIEhvc3RMaXN0ZW5lclxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uJykgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3k6ICcnIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJyB8ICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnIHwgJ3dpbmRvdyc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1jbGljay1tb3JlIGh0bWwgYXR0cmlidXRlXG4gICAqICBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIHRoZSBlbGxpcHNpc0NoYXJhY3RlcnMgd2lsbCBiZVxuICAgKiAgd3JhcHBlZCBpbiA8YT48L2E+IHRhZ3MgYW5kIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZVxuICAgKiAgcGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpbmtcbiAgICovXG4gIEBPdXRwdXQoJ2VsbGlwc2lzLWNsaWNrLW1vcmUnKSBtb3JlQ2xpY2tFbWl0dGVyOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCB0byBxdWlja2x5IGZpbmQgdGhlIGxhcmdlc3QgbnVtYmVyIGZvclxuICAgKiB3aGljaCBgY2FsbGJhY2sobnVtYmVyKWAgc3RpbGwgcmV0dXJucyB0cnVlLlxuICAgKiBAcGFyYW0gIG1heCAgICAgIEhpZ2hlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqIEBwYXJhbSAgY2FsbGJhY2sgU2hvdWxkIHJldHVybiB0cnVlIGFzIGxvbmcgYXMgdGhlIHBhc3NlZCBudW1iZXIgaXMgdmFsaWRcbiAgICogQHJldHVybiAgICAgICAgICBMYXJnZXN0IHBvc3NpYmxlIG51bWJlclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgbnVtZXJpY0JpbmFyeVNlYXJjaChtYXg6IG51bWJlciwgY2FsbGJhY2s6IChuOiBudW1iZXIpID0+IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gbWF4O1xuICAgIGxldCBiZXN0ID0gLTE7XG4gICAgbGV0IG1pZDogbnVtYmVyO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgICAgbWlkID0gfn4oKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayhtaWQpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXN0ID0gbWlkO1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RpdmUncyBjb25zdHJ1Y3RvclxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIG5nWm9uZTogTmdab25lKSB7IH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGluaXQgdmlldyBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIEluaXRpYWxpemVzIHRoZSBlbGVtZW50IGZvciBkaXNwbGF5aW5nIHRoZSBlbGxpcHNpcy5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBsZXQgdGhlIGVsbGlwc2lzIGNoYXJhY3RlcnMgZGVmYXVsdCB0byAnLi4uJzpcbiAgICBpZiAodGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPT09ICcnKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9ICcuLi4nO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vcmVDbGlja0VtaXR0ZXIub2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gYDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJuZ3gtZWxsaXBzaXMtbW9yZVwiPiR7dGhpcy5lbGxpcHNpc0NoYXJhY3RlcnN9PC9hPmA7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSByZWdleCByZXBsYWNlIG9uIHdvcmQgYm91bmRhcmllczpcbiAgICBpZiAoIXRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykge1xuICAgICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJyc7XG4gICAgfVxuICAgIHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9ICdbJyArIHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcy5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKS5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSArICddJztcblxuICAgIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBjb250ZW50cyBvZiB0aGUgZWxlbWVudDpcbiAgICB0aGlzLmVsZW0gPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBpZiAodGhpcy5lbGxpcHNpc0NvbnRlbnQpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gdGhpcy5lbGxpcHNpc0NvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5vcmlnaW5hbFRleHQpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gdGhpcy5lbGVtLmlubmVyVGV4dDtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSB3cmFwcGVyIGRpdiAocmVxdWlyZWQgZm9yIHJlc2l6ZSBldmVudHMgdG8gd29yayBwcm9wZXJseSk6XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW0sICdpbm5lckhUTUwnLCAnJyk7XG4gICAgdGhpcy5pbm5lckVsZW0gPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5pbm5lckVsZW0sICduZ3gtZWxsaXBzaXMtaW5uZXInKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVUZXh0KHRoaXMub3JpZ2luYWxUZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJFbGVtLCB0ZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbSwgdGhpcy5pbm5lckVsZW0pO1xuXG4gICAgLy8gc3RhcnQgbGlzdGVuaW5nIGZvciByZXNpemUgZXZlbnRzOlxuICAgIHRoaXMuYWRkUmVzaXplTGlzdGVuZXIodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGNoYW5nZSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIENoYW5nZSBvcmlnaW5hbCB0ZXh0IChpZiB0aGUgZWxsaXBzaXMtY29udGVudCBoYXMgYmVlbiBwYXNzZWQpXG4gICAqIGFuZCByZS1yZW5kZXJcbiAgICovXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIGlmICghdGhpcy5lbGVtIHx8IHR5cGVvZiB0aGlzLmVsbGlwc2lzQ29udGVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5vcmlnaW5hbFRleHQgPT09IHRoaXMuZWxsaXBzaXNDb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsbGlwc2lzQ29udGVudDtcbiAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgZGVzdHJveSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGFsbCByZXNpemUgbGlzdGVuZXJzXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVSZXNpemVMaXN0ZW5lcigpO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGNhbGwgYXBwbHlFbGxpcHNpcygpIHdoZW5ldmVyIGEgcmVzaXplIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBsaXN0ZW5lciAod2luZG93L2VsZW1lbnQpIGRlcGVuZHMgb24gdGhlIHJlc2l6ZURldGVjdGlvblN0cmF0ZWd5LlxuICAgKiBAcGFyYW0gdHJpZ2dlck5vdz1mYWxzZSBpZiB0cnVlLCB0aGUgZWxsaXBzaXMgaXMgYXBwbGllZCBpbW1lZGlhdGVseVxuICAgKi9cbiAgcHJpdmF0ZSBhZGRSZXNpemVMaXN0ZW5lcih0cmlnZ2VyTm93ID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kgPSAnJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ3dpbmRvdyc6XG4gICAgICAgIHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSA9IHRydWU7XG4gICAgICAgIGlmICh0cmlnZ2VyTm93KSB7XG4gICAgICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnOlxuICAgICAgICB0aGlzLmFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcihmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHR5cGVvZiAoY29uc29sZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYE5vIHN1Y2ggZWxsaXBzaXMtcmVzaXplLWRldGVjdGlvbiBzdHJhdGVneTogJyR7dGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneX0nLiBVc2luZyAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InIGluc3RlYWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN3aXRjaC1jYXNlLWZhbGwtdGhyb3VnaFxuICAgICAgY2FzZSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignd2luZG93OnJlc2l6ZScsIFsnJGV2ZW50J10pIG9uUmVzaXplKGV2ZW50OiBFdmVudCkge1xuICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5hcHBseU9uV2luZG93UmVzaXplKSB7XG4gICAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBjYWxsIGFwcGx5RWxsaXBzaXMoKSB3aGVuZXZlciB0aGUgZWxlbWVudFxuICAgKiBoYXMgYmVlbiByZXNpemVkLlxuICAgKiBAcGFyYW0gc2Nyb2xsU3RyYXRlZ3k9dHJ1ZSBVc2UgdGhlIGRlZmF1bHQgZWxlbWVudFJlc2l6ZURldGVjdG9yJ3MgLSBzdHJhdGVneSAtIHMuIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3JcbiAgICovXG4gIHByaXZhdGUgYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKHNjcm9sbFN0cmF0ZWd5ID0gdHJ1ZSkge1xuICAgIGlmICghRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yKSB7XG4gICAgICBjb25zdCBtYWtlcjogYW55ID0gZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXI7XG4gICAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IgPSBtYWtlcih7IHN0cmF0ZWd5OiBzY3JvbGxTdHJhdGVneSA/ICdzY3JvbGwnIDogJ29iamVjdCcgfSk7XG4gICAgfVxuXG5cbiAgICBsZXQgY2FsbGVkQXN5bmNocm9ub3VzbHkgPSBmYWxzZTtcbiAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IubGlzdGVuVG8odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICgpID0+IHtcbiAgICAgIGlmICghY2FsbGVkQXN5bmNocm9ub3VzbHkpIHtcbiAgICAgICAgLy8gZWxlbWVudFJlc2l6ZURldGVjdG9yIGZpcmVzIHRoZSBldmVudCBkaXJlY3RseSBhZnRlciByZS1hdHRhY2hpbmcgdGhlIGxpc3RlbmVyXG4gICAgICAgIC8vIC0+IGRpc2NhcmQgdGhhdCBmaXJzdCBldmVudDpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgfSk7XG4gICAgY2FsbGVkQXN5bmNocm9ub3VzbHkgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIGZvciBhbnkgcmVzaXplIGV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVSZXNpemVMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSAhPT0gJ3dpbmRvdycpIHtcbiAgICAgIGlmIChFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IgJiYgdGhpcy5lbGVtKSB7XG4gICAgICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvci5yZW1vdmVBbGxMaXN0ZW5lcnModGhpcy5lbGVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBseU9uV2luZG93UmVzaXplID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luYWwgdGV4dCdzIHRydW5jYXRlZCB2ZXJzaW9uLiBJZiB0aGUgdGV4dCByZWFsbHkgbmVlZGVkIHRvXG4gICAqIGJlIHRydW5jYXRlZCwgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggdGhlIHRleHQgbWF5IGhhdmVcbiAgICogQHJldHVybiBzdHJpbmcgICAgICAgdGhlIHRydW5jYXRlZCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgZ2V0VHJ1bmNhdGVkVGV4dChtYXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCB8fCB0aGlzLm9yaWdpbmFsVGV4dC5sZW5ndGggPD0gbWF4KSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFRleHQ7XG4gICAgfVxuXG4gICAgY29uc3QgdHJ1bmNhdGVkVGV4dCA9IHRoaXMub3JpZ2luYWxUZXh0LnN1YnN0cigwLCBtYXgpO1xuICAgIGlmICh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPT09ICdbXScgfHwgdGhpcy5vcmlnaW5hbFRleHQuY2hhckF0KG1heCkubWF0Y2godGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSkge1xuICAgICAgcmV0dXJuIHRydW5jYXRlZFRleHQgKyB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycztcbiAgICB9XG5cbiAgICBsZXQgaSA9IG1heCAtIDE7XG4gICAgd2hpbGUgKGkgPiAwICYmICF0cnVuY2F0ZWRUZXh0LmNoYXJBdChpKS5tYXRjaCh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpKSB7XG4gICAgICBpLS07XG4gICAgfVxuICAgIHJldHVybiB0cnVuY2F0ZWRUZXh0LnN1YnN0cigwLCBpKSArIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJ1bmNhdGVkIHRleHQgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBpbm5lciBkaXZcbiAgICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggdGhlIHRleHQgbWF5IGhhdmVcbiAgICogQHBhcmFtIGFkZE1vcmVMaXN0ZW5lcj1mYWxzZSBsaXN0ZW4gZm9yIGNsaWNrIG9uIHRoZSBlbGxpcHNpc0NoYXJhY3RlcnMgaWYgdGhlIHRleHQgaGFzIGJlZW4gdHJ1bmNhdGVkXG4gICAqL1xuICBwcml2YXRlIHRydW5jYXRlVGV4dChtYXg6IG51bWJlciwgYWRkTW9yZUxpc3RlbmVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRUcnVuY2F0ZWRUZXh0KG1heCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmlubmVyRWxlbSwgJ2lubmVySFRNTCcsIHRleHQpO1xuXG4gICAgaWYgKCFhZGRNb3JlTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIG1vcmUgY2xpY2sgbGlzdGVuZXI6XG4gICAgaWYgKHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZCwgYWRkIGEgbW9yZSBjbGljayBsaXN0ZW5lcjpcbiAgICBpZiAodGV4dCAhPT0gdGhpcy5vcmlnaW5hbFRleHQpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5pbm5lckVsZW0sICdjbGljaycsIChlOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKCFlLnRhcmdldCB8fCBlLnRhcmdldC5jbGFzc05hbWUgIT09ICduZ3gtZWxsaXBzaXMtbW9yZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm1vcmVDbGlja0VtaXR0ZXIuZW1pdChlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IGVsbGlwc2lzIGluIHRoZSBpbm5lciBkaXYgaWYgdGhlIHRleHQgd291bGQgZXhjZWVkIHRoZSBib3VuZGFyaWVzXG4gICAqL1xuICBwcml2YXRlIGFwcGx5RWxsaXBzaXMoKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSByZXNpemUgbGlzdGVuZXIgYXMgY2hhbmdpbmcgdGhlIGNvbnRhaW5lZCB0ZXh0IHdvdWxkIHRyaWdnZXIgZXZlbnRzOlxuICAgIHRoaXMucmVtb3ZlUmVzaXplTGlzdGVuZXIoKTtcblxuICAgIC8vIEZpbmQgdGhlIGJlc3QgbGVuZ3RoIGJ5IHRyaWFsIGFuZCBlcnJvcjpcbiAgICBjb25zdCBtYXhMZW5ndGggPSBFbGxpcHNpc0RpcmVjdGl2ZS5udW1lcmljQmluYXJ5U2VhcmNoKHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCwgY3VyTGVuZ3RoID0+IHtcbiAgICAgIHRoaXMudHJ1bmNhdGVUZXh0KGN1ckxlbmd0aCk7XG4gICAgICByZXR1cm4gIXRoaXMuaXNPdmVyZmxvd2luZztcbiAgICB9KTtcblxuICAgIC8vIEFwcGx5IHRoZSBiZXN0IGxlbmd0aDpcbiAgICB0aGlzLnRydW5jYXRlVGV4dChtYXhMZW5ndGgsICh0aGlzLm1vcmVDbGlja0VtaXR0ZXIub2JzZXJ2ZXJzLmxlbmd0aCA+IDApKTtcblxuICAgIC8vIFJlLWF0dGFjaCB0aGUgcmVzaXplIGxpc3RlbmVyOlxuICAgIHRoaXMuYWRkUmVzaXplTGlzdGVuZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHRleHQgaXMgZXhjZWVkaW5nIHRoZSBlbGVtZW50J3MgYm91bmRhcmllcyBvciBub3RcbiAgICovXG4gIHByaXZhdGUgZ2V0IGlzT3ZlcmZsb3dpbmcoKTogYm9vbGVhbiB7XG4gICAgLy8gRW5mb3JjZSBoaWRkZW4gb3ZlcmZsb3cgKHJlcXVpcmVkIHRvIGNvbXBhcmUgY2xpZW50IHdpZHRoL2hlaWdodCB3aXRoIHNjcm9sbCB3aWR0aC9oZWlnaHQpXG4gICAgY29uc3QgY3VycmVudE92ZXJmbG93ID0gdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93O1xuICAgIGlmICghY3VycmVudE92ZXJmbG93IHx8IGN1cnJlbnRPdmVyZmxvdyA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjb25zdCBpc092ZXJmbG93aW5nID0gdGhpcy5lbGVtLmNsaWVudFdpZHRoIDwgdGhpcy5lbGVtLnNjcm9sbFdpZHRoIC0gMSB8fCB0aGlzLmVsZW0uY2xpZW50SGVpZ2h0IDwgdGhpcy5lbGVtLnNjcm9sbEhlaWdodCAtIDE7XG5cbiAgICAvLyBSZXNldCBvdmVyZmxvdyB0byB0aGUgb3JpZ2luYWwgY29uZmlndXJhdGlvbjpcbiAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSBjdXJyZW50T3ZlcmZsb3c7XG5cbiAgICByZXR1cm4gaXNPdmVyZmxvd2luZztcbiAgfVxufVxuIl19